{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Travaux Pratiques Urbanisation des SI \u00b6 GL5 - INSAT \u00b6 Cours Disponible ici: http://liliasfaxi.wix.com/liliasfaxi/urbanisation Google Classroom : https://classroom.google.com/u/0/c/NTM3NDM1NTU3MDQx Repo Github : https://github.com/INSATunisia/TP-Urbanisation Overview \u00b6 Vous trouverez sur mon site officiel le cours associ\u00e9 \u00e0 ces TPs. L'objectif de ce cours est d'initier les \u00e9tudiants aux architectures d'entreprise, principalement celles \u00e0 base de services en g\u00e9n\u00e9ral, et aux bonnes pratiques d'urbanisation des SI. Le cours va porter principalement sur les points suivants: Les architectures d'entreprise et l'urbanisation des SI Les EIP: Enterprise Integration Patterns L'architecture orient\u00e9e services (SOA: Service-Oriented Architecture) Les bus de services (ESB: Enterprise Service Bus) La composition de services: orchestration et chor\u00e9graphie Le API Management L'architecture orient\u00e9e web (WOA: Web-Oriented Architecture) Ce cours comporte cinq s\u00e9ances de travaux pratiques: TP1 : Manipulation des services SOAP et REST avec Talend TP2 : Mise en place d'un ESB avec Talend ESB TP3 : Orchestration des services avec Camunda TP4 : API Management avec Anypoint Lilia SFAXI Cette \u0153uvre est mise \u00e0 disposition selon les termes de la Licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International .","title":"Travaux Pratiques Urbanisation des SI"},{"location":"#travaux-pratiques-urbanisation-des-si","text":"","title":"Travaux Pratiques Urbanisation des SI"},{"location":"#gl5-insat","text":"Cours Disponible ici: http://liliasfaxi.wix.com/liliasfaxi/urbanisation Google Classroom : https://classroom.google.com/u/0/c/NTM3NDM1NTU3MDQx Repo Github : https://github.com/INSATunisia/TP-Urbanisation","title":"GL5 - INSAT"},{"location":"#overview","text":"Vous trouverez sur mon site officiel le cours associ\u00e9 \u00e0 ces TPs. L'objectif de ce cours est d'initier les \u00e9tudiants aux architectures d'entreprise, principalement celles \u00e0 base de services en g\u00e9n\u00e9ral, et aux bonnes pratiques d'urbanisation des SI. Le cours va porter principalement sur les points suivants: Les architectures d'entreprise et l'urbanisation des SI Les EIP: Enterprise Integration Patterns L'architecture orient\u00e9e services (SOA: Service-Oriented Architecture) Les bus de services (ESB: Enterprise Service Bus) La composition de services: orchestration et chor\u00e9graphie Le API Management L'architecture orient\u00e9e web (WOA: Web-Oriented Architecture) Ce cours comporte cinq s\u00e9ances de travaux pratiques: TP1 : Manipulation des services SOAP et REST avec Talend TP2 : Mise en place d'un ESB avec Talend ESB TP3 : Orchestration des services avec Camunda TP4 : API Management avec Anypoint Lilia SFAXI Cette \u0153uvre est mise \u00e0 disposition selon les termes de la Licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International .","title":"Overview"},{"location":"projet/","text":"Vous allez r\u00e9aliser (par groupes d'une dizaine de personnes) un projet d'urbanisation complet o\u00f9 vous allez simuler la mise en place d'une architecture d'entreprise urbanis\u00e9e pour une entreprise de votre invention. D\u00e9livrables Attendus \u00b6 Un rapport d\u00e9taill\u00e9, d\u00e9crivant les \u00e9tapes de conception du syst\u00e8me et les choix d'impl\u00e9mentation. Un repository Github (ou \u00e9quivalent) comportant le code du syst\u00e8me, bien organis\u00e9 et comment\u00e9, et le fichier XML (Open Exchange File) du projet Archimate. Une pr\u00e9sentation et une d\u00e9mo, de 15 minutes (Date \u00e0 d\u00e9finir avant les examens finaux). Note \u00b6 Ce projet composera 70% de la note de TP, les 30% restants seront sur l'assiduit\u00e9 et la consistance dans la r\u00e9alisation des TPs. Supports n\u00e9cessaires \u00b6 Pour r\u00e9aliser ce projet, je vous donne ici les supports dont vous aurez besoin: Lien Description Tutoriel: Archisurance Case Study T\u00e9l\u00e9charger Archi : Archimate Modeler Archimate pour les nuls: Les fondamentaux Templates de d\u00e9livrables TOGAF Description du Projet \u00b6 Vous allez concevoir une entreprise imaginaire (\u00e0 l'instar de Archisurance, dont je vous ai donn\u00e9 le tutoriel), qui contenait \u00e0 la base un ensemble d'applications \u00e9parpill\u00e9es sur plusieurs d\u00e9partements. Il vous a \u00e9t\u00e9 demand\u00e9 en tant qu'\u00e9quipe de cr\u00e9er une architecture urbanis\u00e9e permettant d'assurer les besoins suivants pour votre entreprise: Assurer des communications fluides entre les diff\u00e9rentes applications et services de l'entreprise. Unifier le langage utilis\u00e9 par les diff\u00e9rents d\u00e9partements. Synchroniser les donn\u00e9es et g\u00e9rer les d\u00e9pendances et les redondances. \u00c9viter au maximum de changer les habitudes de travail des \u00e9quipes, surtout celles des d\u00e9partements RH et finance. On vous demande de respecter les principes TOGAF pour votre nouveau syst\u00e8me. Vous allez donc utiliser Archimate pour cr\u00e9er et concevoir les diagrammes n\u00e9cessaires pour chacune des \u00e9tapes de l'ADM (suivre pour cela l'approche dans le tutoriel). Ces diagrammes seront ensuite utilis\u00e9s pour d\u00e9cider de l'architecture technique \u00e0 mettre en place. Une fois la conception globale r\u00e9alis\u00e9e, vous devez d\u00e9velopper un POC ( proof of concept ) d'un syst\u00e8me urbanis\u00e9 simplifi\u00e9, respectant les contraintes suivantes: Avoir au moins 5 services sur 2 ou 3 d\u00e9partements diff\u00e9rents. Cr\u00e9er au moins 2 processus m\u00e9tiers reliant ces services. Utiliser les outils vus en TP (ou \u00e9quivalents) de fa\u00e7on \u00e0 avoir: Un API gateway Au moins deux ESBs Un serveur de workflow. Rendus \u00b6 Rapport \u00b6 Le rapport s'adresse aux responsables techniques, pour la plupart ayant une id\u00e9e sur TOGAF (certains m\u00eames sont certifi\u00e9s TOGAF) . Il devra \u00eatre complet et pr\u00e9senter les informations suivantes: Une description du m\u00e9tier de l'entreprise, et de la probl\u00e9matique \u00e0 r\u00e9soudre. L'\u00e9tat actuel de l'entreprise (avant urbanisation). Les diff\u00e9rents diagrammes et architectures, en respectant la m\u00e9thode ADM (commencer par les besoins m\u00e9tiers pour arriver aux besoins techniques). Pr\u00e9sentation des choix techniques r\u00e9alis\u00e9s. Pr\u00e9sentation des r\u00e9sultats d'impl\u00e9mentation et d'ex\u00e9cution des workflows. Pr\u00e9sentation \u00b6 La pr\u00e9sentation finale devra durer 15 minutes au maximum (avec 5 minutes de questions/r\u00e9ponses) et sera adress\u00e9e au chef de l'entreprise ainsi qu'aux diff\u00e9rents d\u00e9partements (pas aux responsables techniques) . Vous devez donc savoir pr\u00e9senter l'int\u00e9r\u00eat du nouveau syst\u00e8me (qui va co\u00fbter en temps et argent \u00e0 toutes les parties prenantes) et de valoriser le POC que vous avez d\u00e9velopp\u00e9 avec les quelques services s\u00e9lectionn\u00e9s. Le jour de la pr\u00e9sentation \u00b6 Il faut apporter le rapport imprim\u00e9 avec vous le jour de la pr\u00e9sentation. Chaque groupe va pr\u00e9senter son travail devant l'enseignante et ses autres camarades, qui vont jouer le r\u00f4le des diff\u00e9rent intervenants dans l'entreprise. Vous \u00eates libres de choisir le format de la pr\u00e9sentation.","title":"Projet"},{"location":"projet/#delivrables-attendus","text":"Un rapport d\u00e9taill\u00e9, d\u00e9crivant les \u00e9tapes de conception du syst\u00e8me et les choix d'impl\u00e9mentation. Un repository Github (ou \u00e9quivalent) comportant le code du syst\u00e8me, bien organis\u00e9 et comment\u00e9, et le fichier XML (Open Exchange File) du projet Archimate. Une pr\u00e9sentation et une d\u00e9mo, de 15 minutes (Date \u00e0 d\u00e9finir avant les examens finaux).","title":"D\u00e9livrables Attendus"},{"location":"projet/#note","text":"Ce projet composera 70% de la note de TP, les 30% restants seront sur l'assiduit\u00e9 et la consistance dans la r\u00e9alisation des TPs.","title":"Note"},{"location":"projet/#supports-necessaires","text":"Pour r\u00e9aliser ce projet, je vous donne ici les supports dont vous aurez besoin: Lien Description Tutoriel: Archisurance Case Study T\u00e9l\u00e9charger Archi : Archimate Modeler Archimate pour les nuls: Les fondamentaux Templates de d\u00e9livrables TOGAF","title":"Supports n\u00e9cessaires"},{"location":"projet/#description-du-projet","text":"Vous allez concevoir une entreprise imaginaire (\u00e0 l'instar de Archisurance, dont je vous ai donn\u00e9 le tutoriel), qui contenait \u00e0 la base un ensemble d'applications \u00e9parpill\u00e9es sur plusieurs d\u00e9partements. Il vous a \u00e9t\u00e9 demand\u00e9 en tant qu'\u00e9quipe de cr\u00e9er une architecture urbanis\u00e9e permettant d'assurer les besoins suivants pour votre entreprise: Assurer des communications fluides entre les diff\u00e9rentes applications et services de l'entreprise. Unifier le langage utilis\u00e9 par les diff\u00e9rents d\u00e9partements. Synchroniser les donn\u00e9es et g\u00e9rer les d\u00e9pendances et les redondances. \u00c9viter au maximum de changer les habitudes de travail des \u00e9quipes, surtout celles des d\u00e9partements RH et finance. On vous demande de respecter les principes TOGAF pour votre nouveau syst\u00e8me. Vous allez donc utiliser Archimate pour cr\u00e9er et concevoir les diagrammes n\u00e9cessaires pour chacune des \u00e9tapes de l'ADM (suivre pour cela l'approche dans le tutoriel). Ces diagrammes seront ensuite utilis\u00e9s pour d\u00e9cider de l'architecture technique \u00e0 mettre en place. Une fois la conception globale r\u00e9alis\u00e9e, vous devez d\u00e9velopper un POC ( proof of concept ) d'un syst\u00e8me urbanis\u00e9 simplifi\u00e9, respectant les contraintes suivantes: Avoir au moins 5 services sur 2 ou 3 d\u00e9partements diff\u00e9rents. Cr\u00e9er au moins 2 processus m\u00e9tiers reliant ces services. Utiliser les outils vus en TP (ou \u00e9quivalents) de fa\u00e7on \u00e0 avoir: Un API gateway Au moins deux ESBs Un serveur de workflow.","title":"Description du Projet"},{"location":"projet/#rendus","text":"","title":"Rendus"},{"location":"projet/#rapport","text":"Le rapport s'adresse aux responsables techniques, pour la plupart ayant une id\u00e9e sur TOGAF (certains m\u00eames sont certifi\u00e9s TOGAF) . Il devra \u00eatre complet et pr\u00e9senter les informations suivantes: Une description du m\u00e9tier de l'entreprise, et de la probl\u00e9matique \u00e0 r\u00e9soudre. L'\u00e9tat actuel de l'entreprise (avant urbanisation). Les diff\u00e9rents diagrammes et architectures, en respectant la m\u00e9thode ADM (commencer par les besoins m\u00e9tiers pour arriver aux besoins techniques). Pr\u00e9sentation des choix techniques r\u00e9alis\u00e9s. Pr\u00e9sentation des r\u00e9sultats d'impl\u00e9mentation et d'ex\u00e9cution des workflows.","title":"Rapport"},{"location":"projet/#presentation","text":"La pr\u00e9sentation finale devra durer 15 minutes au maximum (avec 5 minutes de questions/r\u00e9ponses) et sera adress\u00e9e au chef de l'entreprise ainsi qu'aux diff\u00e9rents d\u00e9partements (pas aux responsables techniques) . Vous devez donc savoir pr\u00e9senter l'int\u00e9r\u00eat du nouveau syst\u00e8me (qui va co\u00fbter en temps et argent \u00e0 toutes les parties prenantes) et de valoriser le POC que vous avez d\u00e9velopp\u00e9 avec les quelques services s\u00e9lectionn\u00e9s.","title":"Pr\u00e9sentation"},{"location":"projet/#le-jour-de-la-presentation","text":"Il faut apporter le rapport imprim\u00e9 avec vous le jour de la pr\u00e9sentation. Chaque groupe va pr\u00e9senter son travail devant l'enseignante et ses autres camarades, qui vont jouer le r\u00f4le des diff\u00e9rent intervenants dans l'entreprise. Vous \u00eates libres de choisir le format de la pr\u00e9sentation.","title":"Le jour de la pr\u00e9sentation"},{"location":"tp1-old/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Cr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend. Outils et Versions \u00b6 Talend Open Studio for ESB Version: 8.0.1 MySQL Version latest SOAPUI Version 5.7.0 Pr\u00e9sentation de Talend \u00b6 Talend ESB \u00b6 Talend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services web s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes. Talend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9 Apache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache et a fait plusieurs contributions aux projets Apache. Talend fournit: Un courtier de messages \u00e0 haute performance. Des options de d\u00e9ploiement flexibles Des outils de d\u00e9veloppement pour Eclipse Une interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications Support pour les services web SOAP et REST La m\u00e9diation et le routage Support pour le failover, le monitoring et la s\u00e9curit\u00e9 L\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi. L\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox comme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les diff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es. Talend Open Studio for ESB \u00b6 Talend Open Studio for ESB (TOS-ESB) fournit une interface graphique de d\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des applications REST, des services de donn\u00e9es et des routes de messages. Le d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs repr\u00e9sent\u00e9s dans cette figure: Le bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des donn\u00e9es, des services ou des applications Les blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend d\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et d\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est possible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez basculer gr\u00e2ce \u00e0 Talend Service Locator. Le bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les informations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services. L\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit: Composant Fonctionnalit\u00e9 Le traditionnel Repository contenant vos Jobs, services, fichiers, routes\u2026 La fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes La fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026 La palette des composants \u00e0 utiliser Les onglets pour le choix de la perspective \u00e0 utiliser Service Web SOAP : Helloworld \u00b6 Commen\u00e7ons par installer Talend ESB en d\u00e9zippant simplement le fichier t\u00e9l\u00e9charg\u00e9. Aller ensuite au r\u00e9pertoire Studio, et lancer l'ex\u00e9cutable associ\u00e9 \u00e0 votre syst\u00e8me d'exploitation. Erreur possible pour les utilisateurs MAC Pour ceux qui disposent d'un MAC, si l'erreur suivante appara\u00eet: The TOS_ESB-macosx-cocoa executable launcher was unable to locate its companion shared library. , r\u00e9aliser les actions suivantes (ceci se fera une seule fois): Ouvrir un terminal sous le r\u00e9pertoire Studio Lancer la commande suivante: xattr -c TOS_ESB-macosx-cocoa.app Lancer ensuite l'ex\u00e9cutable une deuxi\u00e8me fois. Cela devra le d\u00e9bloquer. Nous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des services web avec les outils Talend ESB. Nous allons donc commencer avec le traditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix. Dans toute cette partie, nous nous trouverons dans la perspective Integration . Cr\u00e9er le service SOAP \u00b6 Pour cr\u00e9er un nouveau service de type SOAP: Clic-droit sur Services de votre Repository, et choisir Create Service . Appeler le service HelloWorldService . Cliquer sur Suivant. On vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer. Un service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est cr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche. Configurer le service SOAP \u00b6 Pour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord: Importer le WSDL de votre service dans votre repository. Pour cela, clic droit sur HelloWorldService , et choisir Importer les sch\u00e9mas WSDL . Vous retrouverez votre WSDL dans la partie Metadonn\u00e9es -> Fichier XML . Cr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration HelloWorldServiceOperation (sous Services) et choisir Assign Job . Modifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le tLogRow nous permettra d\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au consommateur): Astuce Il est conseill\u00e9 de relier d'abord les composants tXMLMap et tESBProviderResponse_1 , puis d'ins\u00e9rer le tLogRow . On vous demandera en reliant les deux premiers composants : R\u00e9cup\u00e9rer le sch\u00e9ma du composant cible? . Cliquer sur Oui . Configurer votre tXMLMap pour que le in de la requ\u00eate soit transmise au out de la r\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela: Double clic sur votre XML Map. Clic-droit sur payload de l\u2019entr\u00e9e, et cliquer sur Import from Repository . Choisir le HelloWorldServiceOperationRequest correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9. Refaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant HelloWorldServiceOperationResponse . Relier le in de la requ\u00eate avec le out de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse) Modifier l\u2019expression du out en ajoutant la cha\u00eene \u201cHello \u201c avant la valeur in de l\u2019entr\u00e9e. Le r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit: Sauvegarder et quitter. Lancer votre Job (cela permettra de publier votre service web sur le port 8090). V\u00e9rifier que votre fichier WSDL existe bien. Tester le service SOAP \u00b6 Il est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9 SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale Donner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit: Double cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le ? par un nom de votre choix. Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant: Consommer le service SOAP \u00b6 Nous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela: Cr\u00e9er un nouveau Job, que vous appellerez HelloWorldServiceConsumer . Concevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante: Voici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 : tFixedFlowInput : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service tXMLMap : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service tESBConsumer : consommateur du service tLogRow : afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a) Configurer votre composant tFixedFlowInput . Pour cela: Cliquer sur Modifier le sch\u00e9ma et ajouter une colonne appel\u00e9e Nom de type String . Utiliser une Inline Table pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d. Configurer votre tESBConsumer en lui donnant comme WSDL celui du service que vous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090. Configurer votre tXMLMap pour que la variable Nom soit associ\u00e9e au in de votre service. Ex\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant: Service Web REST : Interrogation d'une base de donn\u00e9es \u00b6 Nous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es. Cr\u00e9er et se connecter \u00e0 la base de donn\u00e9es \u00b6 Nous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e urbanisation-tp1 avec une table, que nous appellerons user . Cette table contient les champs id , firstname et lastname . Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es. Elle devra ressembler \u00e0 ce qui suit: Pour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes: Dans les M\u00e9tadonn\u00e9es, sous Connexions aux bases de donn\u00e9es , clic-droit, puis choisir: Cr\u00e9er une connexion . Configurer votre connexion. Voici un exemple: Une fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -> Connexions... -> et choisir: R\u00e9cup\u00e9rer le sch\u00e9ma . S\u00e9lectionner la table user , et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma. Cr\u00e9er le service REST \u00b6 Nous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera DBService , puis glisser les composants suivants: tRestRequest : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler user : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous Sch\u00e9mas des tables , glisser la table user vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet. Remarque Je choisis tMySQLInput car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le Input ). tFlowToIterate : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales. tXMLMap : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate. tRestResponse : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate. tLogRow : Pour le log, bien s\u00fbr. Le job aura l'allure suivante: Configurer le service REST \u00b6 Nous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI: http://localhost:8088/users?from=1&to=3 , le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3. tRestRequest \u00b6 tRestRequest devra \u00eatre configur\u00e9 comme suit: La valeur de Endpoint URL devra \u00eatre: \"http://localhost:8088/users\" Si vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9 getUsers , vous devriez le retrouver dans la case REST API Mapping . Sinon, cr\u00e9ez-le. Garder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON). En cliquant sur getUsers , un bouton avec trois petits points appara\u00eet. Cliquez dessus. Ajouter les deux colonnes from et to repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que: Leur type soit int Leurs valeurs par d\u00e9faut soient respectivement 1 et 3. Remarque Ces valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres. Leur commentaire ait la valeur: query Remarque Cela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path. La table user \u00b6 Puisque le composant user a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires. Il suffira dans notre cas de: Cliquer sur Guess Schema pour charger le sch\u00e9ma de la base. Changer la requ\u00eate pour qu'elle soit comme suit: \"SELECT * FROM `user` where id>=\" + globalMap . get ( \"getUsers.from\" ) + \" and id<=\" + globalMap . get ( \"getUsers.to\" ) Remarque globalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres. Ici on suppose que le nom de votre lien est getUsers . Si ce n'est pas le cas changez-le dans la requ\u00eate. tXMLMap \u00b6 Cliquer deux fois sur la tXMLMap pour la configurer. Dans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e body dont le type est Document . Cette colonne contient un \u00e9l\u00e9ment root . Renommer cet \u00e9l\u00e9ment pour users . Ajouter un sous-\u00e9l\u00e9ment \u00e0 users appel\u00e9 user . D\u00e9finir cet \u00e9l\u00e9ment comme loop Element . Glisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le user . Cr\u00e9ez-le comme attribut du noeud cible. De m\u00eame pour le firstname et lastname , qui seront, eux, des sous-\u00e9l\u00e9ments du noeud user . Dans la colonne de droite, cliquer sur la petite clef \u00e0 molette ( ). Mettre la valeur de \"All in one\" \u00e0 true . Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux. La configuration finale sera donc comme suit: Indication La configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante: <users> <user id= 1 > <firstname> flen </firstname> <lastname> fouleni </lastname> </user> <user id= 2 > <firstname> flena </firstname> <lastname> foulenia </lastname> </user> <users> Les autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur Ex\u00e9cuter . Tester le service REST \u00b6 Dans un navigateur \u00b6 Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix. Par exemple, la requ\u00eate suivante : http://localhost:8088/users?from=2&to=4 donnera: <users> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> <user id= \"4\" > <firstname> Monia </firstname> <lastname> Landolsi </lastname> </user> </users> Si aucun param\u00e8tre n'est indiqu\u00e9: http://localhost:8088/users cela donnera: <users> <user id= \"1\" > <firstname> Ahmed </firstname> <lastname> Ramzi </lastname> </user> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> </users> Avec SOAPUI \u00b6 Il est possible de tester votre service REST avec SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale Entrer l'URI que vous d\u00e9sirez tester: http://localhost:8088/users?from=2&to=4 La fen\u00eatre suivante devrait appara\u00eetre: Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant: Consommer le service REST \u00b6 Pour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant: Configurer le tRestClient comme suit: Ex\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci: Homework \u00b6 Projet E1 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 1 du projet, qui consiste \u00e0: Trouver le concept de votre entreprise (nom, logo, m\u00e9tier, et d\u00e9partements) R\u00e9aliser le tutoriel : Archisurance (voir les supports du projet) Commencer \u00e0 r\u00e9aliser les diagrammes de votre propre entreprise.","title":"Tp1 old"},{"location":"tp1-old/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp1-old/#objectifs-du-tp","text":"Cr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend.","title":"Objectifs du TP"},{"location":"tp1-old/#outils-et-versions","text":"Talend Open Studio for ESB Version: 8.0.1 MySQL Version latest SOAPUI Version 5.7.0","title":"Outils et Versions"},{"location":"tp1-old/#presentation-de-talend","text":"","title":"Pr\u00e9sentation de Talend"},{"location":"tp1-old/#talend-esb","text":"Talend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services web s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes. Talend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9 Apache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache et a fait plusieurs contributions aux projets Apache. Talend fournit: Un courtier de messages \u00e0 haute performance. Des options de d\u00e9ploiement flexibles Des outils de d\u00e9veloppement pour Eclipse Une interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications Support pour les services web SOAP et REST La m\u00e9diation et le routage Support pour le failover, le monitoring et la s\u00e9curit\u00e9 L\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi. L\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox comme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les diff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es.","title":"Talend ESB"},{"location":"tp1-old/#talend-open-studio-for-esb","text":"Talend Open Studio for ESB (TOS-ESB) fournit une interface graphique de d\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des applications REST, des services de donn\u00e9es et des routes de messages. Le d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs repr\u00e9sent\u00e9s dans cette figure: Le bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des donn\u00e9es, des services ou des applications Les blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend d\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et d\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est possible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez basculer gr\u00e2ce \u00e0 Talend Service Locator. Le bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les informations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services. L\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit: Composant Fonctionnalit\u00e9 Le traditionnel Repository contenant vos Jobs, services, fichiers, routes\u2026 La fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes La fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026 La palette des composants \u00e0 utiliser Les onglets pour le choix de la perspective \u00e0 utiliser","title":"Talend Open Studio for ESB"},{"location":"tp1-old/#service-web-soap-helloworld","text":"Commen\u00e7ons par installer Talend ESB en d\u00e9zippant simplement le fichier t\u00e9l\u00e9charg\u00e9. Aller ensuite au r\u00e9pertoire Studio, et lancer l'ex\u00e9cutable associ\u00e9 \u00e0 votre syst\u00e8me d'exploitation. Erreur possible pour les utilisateurs MAC Pour ceux qui disposent d'un MAC, si l'erreur suivante appara\u00eet: The TOS_ESB-macosx-cocoa executable launcher was unable to locate its companion shared library. , r\u00e9aliser les actions suivantes (ceci se fera une seule fois): Ouvrir un terminal sous le r\u00e9pertoire Studio Lancer la commande suivante: xattr -c TOS_ESB-macosx-cocoa.app Lancer ensuite l'ex\u00e9cutable une deuxi\u00e8me fois. Cela devra le d\u00e9bloquer. Nous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des services web avec les outils Talend ESB. Nous allons donc commencer avec le traditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix. Dans toute cette partie, nous nous trouverons dans la perspective Integration .","title":"Service Web SOAP : Helloworld"},{"location":"tp1-old/#creer-le-service-soap","text":"Pour cr\u00e9er un nouveau service de type SOAP: Clic-droit sur Services de votre Repository, et choisir Create Service . Appeler le service HelloWorldService . Cliquer sur Suivant. On vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer. Un service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est cr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche.","title":"Cr\u00e9er le service SOAP"},{"location":"tp1-old/#configurer-le-service-soap","text":"Pour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord: Importer le WSDL de votre service dans votre repository. Pour cela, clic droit sur HelloWorldService , et choisir Importer les sch\u00e9mas WSDL . Vous retrouverez votre WSDL dans la partie Metadonn\u00e9es -> Fichier XML . Cr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration HelloWorldServiceOperation (sous Services) et choisir Assign Job . Modifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le tLogRow nous permettra d\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au consommateur): Astuce Il est conseill\u00e9 de relier d'abord les composants tXMLMap et tESBProviderResponse_1 , puis d'ins\u00e9rer le tLogRow . On vous demandera en reliant les deux premiers composants : R\u00e9cup\u00e9rer le sch\u00e9ma du composant cible? . Cliquer sur Oui . Configurer votre tXMLMap pour que le in de la requ\u00eate soit transmise au out de la r\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela: Double clic sur votre XML Map. Clic-droit sur payload de l\u2019entr\u00e9e, et cliquer sur Import from Repository . Choisir le HelloWorldServiceOperationRequest correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9. Refaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant HelloWorldServiceOperationResponse . Relier le in de la requ\u00eate avec le out de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse) Modifier l\u2019expression du out en ajoutant la cha\u00eene \u201cHello \u201c avant la valeur in de l\u2019entr\u00e9e. Le r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit: Sauvegarder et quitter. Lancer votre Job (cela permettra de publier votre service web sur le port 8090). V\u00e9rifier que votre fichier WSDL existe bien.","title":"Configurer le service SOAP"},{"location":"tp1-old/#tester-le-service-soap","text":"Il est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9 SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale Donner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit: Double cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le ? par un nom de votre choix. Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:","title":"Tester le service SOAP"},{"location":"tp1-old/#consommer-le-service-soap","text":"Nous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela: Cr\u00e9er un nouveau Job, que vous appellerez HelloWorldServiceConsumer . Concevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante: Voici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 : tFixedFlowInput : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service tXMLMap : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service tESBConsumer : consommateur du service tLogRow : afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a) Configurer votre composant tFixedFlowInput . Pour cela: Cliquer sur Modifier le sch\u00e9ma et ajouter une colonne appel\u00e9e Nom de type String . Utiliser une Inline Table pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d. Configurer votre tESBConsumer en lui donnant comme WSDL celui du service que vous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090. Configurer votre tXMLMap pour que la variable Nom soit associ\u00e9e au in de votre service. Ex\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant:","title":"Consommer le service SOAP"},{"location":"tp1-old/#service-web-rest-interrogation-dune-base-de-donnees","text":"Nous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es.","title":"Service Web REST : Interrogation d'une base de donn\u00e9es"},{"location":"tp1-old/#creer-et-se-connecter-a-la-base-de-donnees","text":"Nous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e urbanisation-tp1 avec une table, que nous appellerons user . Cette table contient les champs id , firstname et lastname . Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es. Elle devra ressembler \u00e0 ce qui suit: Pour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes: Dans les M\u00e9tadonn\u00e9es, sous Connexions aux bases de donn\u00e9es , clic-droit, puis choisir: Cr\u00e9er une connexion . Configurer votre connexion. Voici un exemple: Une fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -> Connexions... -> et choisir: R\u00e9cup\u00e9rer le sch\u00e9ma . S\u00e9lectionner la table user , et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma.","title":"Cr\u00e9er et se connecter \u00e0 la base de donn\u00e9es"},{"location":"tp1-old/#creer-le-service-rest","text":"Nous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera DBService , puis glisser les composants suivants: tRestRequest : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler user : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous Sch\u00e9mas des tables , glisser la table user vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet. Remarque Je choisis tMySQLInput car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le Input ). tFlowToIterate : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales. tXMLMap : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate. tRestResponse : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate. tLogRow : Pour le log, bien s\u00fbr. Le job aura l'allure suivante:","title":"Cr\u00e9er le service REST"},{"location":"tp1-old/#configurer-le-service-rest","text":"Nous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI: http://localhost:8088/users?from=1&to=3 , le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3.","title":"Configurer le service REST"},{"location":"tp1-old/#trestrequest","text":"tRestRequest devra \u00eatre configur\u00e9 comme suit: La valeur de Endpoint URL devra \u00eatre: \"http://localhost:8088/users\" Si vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9 getUsers , vous devriez le retrouver dans la case REST API Mapping . Sinon, cr\u00e9ez-le. Garder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON). En cliquant sur getUsers , un bouton avec trois petits points appara\u00eet. Cliquez dessus. Ajouter les deux colonnes from et to repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que: Leur type soit int Leurs valeurs par d\u00e9faut soient respectivement 1 et 3. Remarque Ces valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres. Leur commentaire ait la valeur: query Remarque Cela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path.","title":"tRestRequest"},{"location":"tp1-old/#la-table-user","text":"Puisque le composant user a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires. Il suffira dans notre cas de: Cliquer sur Guess Schema pour charger le sch\u00e9ma de la base. Changer la requ\u00eate pour qu'elle soit comme suit: \"SELECT * FROM `user` where id>=\" + globalMap . get ( \"getUsers.from\" ) + \" and id<=\" + globalMap . get ( \"getUsers.to\" ) Remarque globalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres. Ici on suppose que le nom de votre lien est getUsers . Si ce n'est pas le cas changez-le dans la requ\u00eate.","title":"La table user"},{"location":"tp1-old/#txmlmap","text":"Cliquer deux fois sur la tXMLMap pour la configurer. Dans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e body dont le type est Document . Cette colonne contient un \u00e9l\u00e9ment root . Renommer cet \u00e9l\u00e9ment pour users . Ajouter un sous-\u00e9l\u00e9ment \u00e0 users appel\u00e9 user . D\u00e9finir cet \u00e9l\u00e9ment comme loop Element . Glisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le user . Cr\u00e9ez-le comme attribut du noeud cible. De m\u00eame pour le firstname et lastname , qui seront, eux, des sous-\u00e9l\u00e9ments du noeud user . Dans la colonne de droite, cliquer sur la petite clef \u00e0 molette ( ). Mettre la valeur de \"All in one\" \u00e0 true . Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux. La configuration finale sera donc comme suit: Indication La configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante: <users> <user id= 1 > <firstname> flen </firstname> <lastname> fouleni </lastname> </user> <user id= 2 > <firstname> flena </firstname> <lastname> foulenia </lastname> </user> <users> Les autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur Ex\u00e9cuter .","title":"tXMLMap"},{"location":"tp1-old/#tester-le-service-rest","text":"","title":"Tester le service REST"},{"location":"tp1-old/#dans-un-navigateur","text":"Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix. Par exemple, la requ\u00eate suivante : http://localhost:8088/users?from=2&to=4 donnera: <users> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> <user id= \"4\" > <firstname> Monia </firstname> <lastname> Landolsi </lastname> </user> </users> Si aucun param\u00e8tre n'est indiqu\u00e9: http://localhost:8088/users cela donnera: <users> <user id= \"1\" > <firstname> Ahmed </firstname> <lastname> Ramzi </lastname> </user> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> </users>","title":"Dans un navigateur"},{"location":"tp1-old/#avec-soapui","text":"Il est possible de tester votre service REST avec SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale Entrer l'URI que vous d\u00e9sirez tester: http://localhost:8088/users?from=2&to=4 La fen\u00eatre suivante devrait appara\u00eetre: Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:","title":"Avec SOAPUI"},{"location":"tp1-old/#consommer-le-service-rest","text":"Pour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant: Configurer le tRestClient comme suit: Ex\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci:","title":"Consommer le service REST"},{"location":"tp1-old/#homework","text":"Projet E1 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 1 du projet, qui consiste \u00e0: Trouver le concept de votre entreprise (nom, logo, m\u00e9tier, et d\u00e9partements) R\u00e9aliser le tutoriel : Archisurance (voir les supports du projet) Commencer \u00e0 r\u00e9aliser les diagrammes de votre propre entreprise.","title":"Homework"},{"location":"tp1/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Cr\u00e9ation et consommation de web services SOAP en utilisant l'outil Anypoint Studio. Outils et Versions \u00b6 Anypoint Studio 7 and Mule ESB 4 MySQL Version latest SOAPUI (Open Source) Version 5.7.0 VSCode Version latest Pr\u00e9sentation des outils \u00b6 Anypoint Platform \u00b6 Anypoint est une plateforme d\u00e9velopp\u00e9e par l\u2019entreprise Mulesoft qui offre les outils n\u00e9cessaires pour la gestion d\u2019APIs et l'int\u00e9gration de services. Gr\u00e2ce \u00e0 Anypoint, Mulesoft est class\u00e9e par Gartner dans son Magic Quadrant dans la rubrique \u201cEnterprise Integration Platform as a Service\u201d de D\u00e9cembre 2022 parmi les leaders du march\u00e9. Mule ESB \u00b6 Mule, le runtime engine d'Anypoint Platform, est un ESB (enterprise service bus) l\u00e9ger bas\u00e9 sur Java ainsi qu'une plateforme d'int\u00e9gration qui permet aux d\u00e9veloppeurs de connecter des applications rapidement et facilement afin qu'elles puissent \u00e9changer des donn\u00e9es. Cela facilite l'int\u00e9gration des syst\u00e8mes existants, quelles que soient les technologies utilis\u00e9es par les applications, notamment JMS, Web Services, JDBC, HTTP, etc. Cet ESB, d\u00e9ployable n'importe o\u00f9, qui int\u00e8gre et orchestre les \u00e9v\u00e9nements en temps r\u00e9el ou par lots, dispose d'une connectivit\u00e9 universelle. Mule ESB propose les services suivants: Cr\u00e9ation et h\u00e9bergement de services M\u00e9diation de services Routage des messages Transformation des donn\u00e9es Anypoint Studio \u00b6 Anypoint Studio fournit une interface graphique de d\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web, des services de donn\u00e9es et des routes de messages. Cr\u00e9ation d'un service web SOAP avec Anypoint Studio et Mule \u00b6 Il est possible de cr\u00e9er un service web SOAP avec Anypoint en utilisant les connecteurs fournis, et tr\u00e8s peu de lignes de code. Nous allons simuler le comportement du service web d\u00e9crit dans le tutoriel suivant: https://spring.io/guides/gs/producing-web-service . 1. Exposition d'un service web SOAP \u00e0 partir d'un fichier WSDL existant \u00b6 Nous r\u00e9cup\u00e9rons d'abord le fichier WSDL du service. Il est possible de g\u00e9n\u00e9rer un fichier WSDL avec des outils tel que Eclipse, mais nous allons nous contenter d'en utiliser un qui est pr\u00eat. Vous trouverez le fichier wsdl \u00e0 t\u00e9l\u00e9charger ici : . Le web service SOAP que nous allons cr\u00e9er prend en entr\u00e9e un pays (nous accepterons pour le moment Spain ou Poland ), et nous donne sa population, sa capitale et sa monnaie. Nous allons suivre les \u00e9tapes suivantes pour cr\u00e9er ce service avec Anypoint Studio. Cr\u00e9er un nouveau Mule Project, qu'on appellera TP1. Dans la fen\u00eatre de cr\u00e9ation : Indiquer que le runtime est bien Mule Server 4.4.0 Installer le runtime suppl\u00e9mentaire suivant: Anypoint APIkit SOAP Plugin Indiquer que le wsdl est le fichier que vous venez de t\u00e9l\u00e9charger. Pour cela, cliquer sur \"Import RAML from local file\" et choisir le fichier wsdl. V\u00e9rifier que le service et le port s'affichent bien comme suit: Une fois le projet cr\u00e9\u00e9, la fen\u00eatre suivante va appara\u00eetre: En cliquant sur Listener , vous pouvez trouver (en bas de l'\u00e9cran) les informations de base du service SOAP expos\u00e9, qui est d\u00e9crit par votre wsdl, tel qu'indiqu\u00e9 dans la figure suivante: Le path (1), domaine et port (2) permettent de repr\u00e9senter l'URL du service qui sera expos\u00e9. Pour tester cela, lancer le service, en faisant un clic-droit sur la fen\u00eatre principale, et en choisissant: Run project tp1 . Remarque Prenez soin d'utiliser une version de JDK entre 8 et 12, car ce sont celles compatibles avec le serveur Mule 4.4. Une fois le service lanc\u00e9, v\u00e9rifiez bien que le wsdl est expos\u00e9, sur l'URL: http://localhost:8081/CountriesPortService/CountriesPortSoap11?wsdl 2. Test du service web avec SOAP UI \u00b6 Nous allons maintenant tester notre service web. Comme vous le savez certainement, pour tester un service web SOAP, il faut \u00e9crire une SOAP Request (en XML), pour obtenir un SOAP Response de la part du service. Pour cela, nous utilisons un outil de test l\u00e9ger, appel\u00e9 SOAP UI. Lancer SOAP UI, et cr\u00e9er un nouveau projet SOAP. Ensuite: Nommer le projet TP1 par exemple. Coller l'URL du WSDL dans le champs Initial WSDL Dans le projet cr\u00e9\u00e9, naviguer vers TP1 -> CountriesPortSoap11 -> getCountry -> Request1 et double cliquer dessus. Une fen\u00eatre s'ouvre, comme suit: Pour tester le service, il suffit de remplacer le ? dans la balise ? par le nom d'un pays, par exemple Spain . Lancer le service en cliquant sur la fl\u00e8che verte. Que constatez-vous? Bien entendu, rien ne va vraiment se passer, car le service n'a pas encore \u00e9t\u00e9 impl\u00e9ment\u00e9. Tout ce qu'on a fait, c'est de donner une sp\u00e9cification vide. La r\u00e9ponse qui s'affiche est un fichier XML affichant une erreur semblable \u00e0 la suivante: Operation [getCountry:\\soapkit-config] not implemented . Nous allons montrer dans ce qui suit comment corriger cette erreur, pour afficher les informations d'un pays donn\u00e9 en param\u00e8tre. 3. Impl\u00e9mentation du service \u00b6 Le deuxi\u00e8me rectangle dans la fen\u00eatre principale de Anypoint permet de d\u00e9finir le comportement du service suite \u00e0 la r\u00e9ception d'un SOAP Request. Il contient pour le moment un seul composant : Transform Message . En cliquant dessus, vous retrouverez dans l'output le message d'erreur qui vous a \u00e9t\u00e9 retourn\u00e9 pr\u00e9c\u00e9demment. Ceci veut dire que le comportement du service n'a pas \u00e9t\u00e9 impl\u00e9ment\u00e9. Pour le faire, nous allons suivre les \u00e9tapes suivantes: Cliquer sur le composant Transform Message . Dans ses propri\u00e9t\u00e9s, trois colonnes sont affich\u00e9es tel que repr\u00e9sent\u00e9 dans la figure suivante: - Input: le squelette de la SOAP Request - Output (graphique): le squelette de la SOAP Response. - Output (code): le code XML correspondant \u00e0 la SOAP Response. Supprimer le bloc Soap#Fault du code XML. Glisser la variable name de l'Input vers la variable name de l'output graphique. Observez comment le code XML a \u00e9galement chang\u00e9. Double cliquer sur le champs population dans la colonne dde l'output graphique. Le code appropri\u00e9 sera g\u00e9n\u00e9r\u00e9 dans le XML. Remplacer la valeur null par la valeur de la population en Espagne (47420000 \u00e0 ce jour). Faites de m\u00eame pour indiquer la capitale ( Madrid ) et la monnaie ( EUR ). Le r\u00e9sultat devra ressembler \u00e0 ce qui suit: Relancer le service si vous l'avez ferm\u00e9, et observez le r\u00e9sultat sur SOAPUI. Cela a l'air de bien marcher! Cela dit, le service donnera toujours le m\u00eame r\u00e9sultat (population/capitale/monnaie), quelque soit l'input saisi dans pays. Nous allons essayer dans ce qui suit de le rendre un peu plus flexible, toujours sans \u00e9crire une ligne de code! 4. Impl\u00e9mentation d'une condition \u00b6 Pour impl\u00e9menter une condition dans notre service, qui donne un output diff\u00e9rent selon l'entr\u00e9e qui lui est donn\u00e9e, nous allons suivre les \u00e9tapes suivantes: Nous allons d'abord cr\u00e9er une variable country , qu'on va alimenter \u00e0 partir de l'input. Pour cela: Glisser le composant Set Variable de la palette juste avant Transform Message Donner le nom country \u00e0 la variable. Dans le champ Value , cliquer sur le bouton . \u00c9crire quelque chose dans le champ qui s'affiche (par exemple country ) Cliquer ensuite sur le bouton pour mapper l'entr\u00e9e \u00e0 la variable. Dans la fen\u00eatre qui s'affiche, glisser l'\u00e9l\u00e9ment name de la requ\u00eate vers la chaine String (dans l'output graphique). La valeur que vous avez saisi sera \u00e9cras\u00e9e par l'expression du nom en entr\u00e9e. Cliquer sur Done \u00c0 partir de la palette, glisser le composant Choice avant Transform Message Glisser ensuite Transform Message dans le When Cliquer sur le When pour d\u00e9finir la condition. Dans le champ Expression , cliquer sur le bouton , puis taper directement la condition: vars.country == 'Spain' Pour ajouter une autre condition (un else if ), glisser un nouveau Transform Message de la palette vers l'extr\u00e9mit\u00e9 droite du box Choice . Refaire ensuite les op\u00e9rations pr\u00e9c\u00e9dentes pour un autre pays, tel que la Tunisie. Dans le box Default , cr\u00e9er un message d'erreur qui ressemble \u00e0 celui qu'on avait \u00e0 la cr\u00e9ation du service, qui indique que le pays donn\u00e9 en entr\u00e9e n'est pas pris en charge. Lancer le service, et v\u00e9rifier avec SOAPUI que toutes les conditions sont bien prises en compte. Attention Prenez des imprim-\u00e9crans d\u00e8s que a marche, vous en aurez besoin dans le rapport! Consultation d'une base de donn\u00e9es \u00b6 Nous allons montrer dans ce qui suit les \u00e9tapes n\u00e9cessaires pour configurer et faire appel \u00e0 une base de donn\u00e9es. Nous allons utiliser MySQL dans notre exemple. 1. Cr\u00e9ation et population de la base \u00b6 Pour cela: Cr\u00e9er une nouvelle base de donn\u00e9es avec MySQL. On l'appellera Countries. Lancer le script SQL suivant pour cr\u00e9er la table countries popul\u00e9e avec plusieurs exemples de pays: Consulter votre base pour voir son contenu et sa structure. 2. Modification du flux \u00b6 Modifier le flux getCountry de fa\u00e7on \u00e0 ce qu'il ressemble \u00e0 l'image suivante: Set Variable permet de cr\u00e9er une variable country qui saisit l'entr\u00e9e dans la SOAP Request. Logger permet d'afficher le contenu de la variable saisie sur la console, sous la forme: \"Pays: <nom_pays>\" . Select contient la requ\u00eate de s\u00e9lection de la base de donn\u00e9es, filtr\u00e9e par le pays donn\u00e9 en entr\u00e9e. Transform Message retourne dans la SOAP Response, les informations du pays en entr\u00e9e, extraites de la base de donn\u00e9es. Le r\u00e9sultat attendu ressemble au suivant: Projet \u00b6 \u00c9tape 1 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 1 du projet, qui consiste \u00e0: Trouver le concept de votre entreprise (nom, logo, m\u00e9tier, et d\u00e9partements) R\u00e9aliser le tutoriel : Archisurance (voir les supports du projet) Commencer \u00e0 r\u00e9aliser les diagrammes de votre propre entreprise.","title":"TP1 - Services Web SOAP avec Mule ESB"},{"location":"tp1/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp1/#objectifs-du-tp","text":"Cr\u00e9ation et consommation de web services SOAP en utilisant l'outil Anypoint Studio.","title":"Objectifs du TP"},{"location":"tp1/#outils-et-versions","text":"Anypoint Studio 7 and Mule ESB 4 MySQL Version latest SOAPUI (Open Source) Version 5.7.0 VSCode Version latest","title":"Outils et Versions"},{"location":"tp1/#presentation-des-outils","text":"","title":"Pr\u00e9sentation des outils"},{"location":"tp1/#anypoint-platform","text":"Anypoint est une plateforme d\u00e9velopp\u00e9e par l\u2019entreprise Mulesoft qui offre les outils n\u00e9cessaires pour la gestion d\u2019APIs et l'int\u00e9gration de services. Gr\u00e2ce \u00e0 Anypoint, Mulesoft est class\u00e9e par Gartner dans son Magic Quadrant dans la rubrique \u201cEnterprise Integration Platform as a Service\u201d de D\u00e9cembre 2022 parmi les leaders du march\u00e9.","title":"Anypoint Platform"},{"location":"tp1/#mule-esb","text":"Mule, le runtime engine d'Anypoint Platform, est un ESB (enterprise service bus) l\u00e9ger bas\u00e9 sur Java ainsi qu'une plateforme d'int\u00e9gration qui permet aux d\u00e9veloppeurs de connecter des applications rapidement et facilement afin qu'elles puissent \u00e9changer des donn\u00e9es. Cela facilite l'int\u00e9gration des syst\u00e8mes existants, quelles que soient les technologies utilis\u00e9es par les applications, notamment JMS, Web Services, JDBC, HTTP, etc. Cet ESB, d\u00e9ployable n'importe o\u00f9, qui int\u00e8gre et orchestre les \u00e9v\u00e9nements en temps r\u00e9el ou par lots, dispose d'une connectivit\u00e9 universelle. Mule ESB propose les services suivants: Cr\u00e9ation et h\u00e9bergement de services M\u00e9diation de services Routage des messages Transformation des donn\u00e9es","title":"Mule ESB"},{"location":"tp1/#anypoint-studio","text":"Anypoint Studio fournit une interface graphique de d\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web, des services de donn\u00e9es et des routes de messages.","title":"Anypoint Studio"},{"location":"tp1/#creation-dun-service-web-soap-avec-anypoint-studio-et-mule","text":"Il est possible de cr\u00e9er un service web SOAP avec Anypoint en utilisant les connecteurs fournis, et tr\u00e8s peu de lignes de code. Nous allons simuler le comportement du service web d\u00e9crit dans le tutoriel suivant: https://spring.io/guides/gs/producing-web-service .","title":"Cr\u00e9ation d'un service web SOAP avec Anypoint Studio et Mule"},{"location":"tp1/#1-exposition-dun-service-web-soap-a-partir-dun-fichier-wsdl-existant","text":"Nous r\u00e9cup\u00e9rons d'abord le fichier WSDL du service. Il est possible de g\u00e9n\u00e9rer un fichier WSDL avec des outils tel que Eclipse, mais nous allons nous contenter d'en utiliser un qui est pr\u00eat. Vous trouverez le fichier wsdl \u00e0 t\u00e9l\u00e9charger ici : . Le web service SOAP que nous allons cr\u00e9er prend en entr\u00e9e un pays (nous accepterons pour le moment Spain ou Poland ), et nous donne sa population, sa capitale et sa monnaie. Nous allons suivre les \u00e9tapes suivantes pour cr\u00e9er ce service avec Anypoint Studio. Cr\u00e9er un nouveau Mule Project, qu'on appellera TP1. Dans la fen\u00eatre de cr\u00e9ation : Indiquer que le runtime est bien Mule Server 4.4.0 Installer le runtime suppl\u00e9mentaire suivant: Anypoint APIkit SOAP Plugin Indiquer que le wsdl est le fichier que vous venez de t\u00e9l\u00e9charger. Pour cela, cliquer sur \"Import RAML from local file\" et choisir le fichier wsdl. V\u00e9rifier que le service et le port s'affichent bien comme suit: Une fois le projet cr\u00e9\u00e9, la fen\u00eatre suivante va appara\u00eetre: En cliquant sur Listener , vous pouvez trouver (en bas de l'\u00e9cran) les informations de base du service SOAP expos\u00e9, qui est d\u00e9crit par votre wsdl, tel qu'indiqu\u00e9 dans la figure suivante: Le path (1), domaine et port (2) permettent de repr\u00e9senter l'URL du service qui sera expos\u00e9. Pour tester cela, lancer le service, en faisant un clic-droit sur la fen\u00eatre principale, et en choisissant: Run project tp1 . Remarque Prenez soin d'utiliser une version de JDK entre 8 et 12, car ce sont celles compatibles avec le serveur Mule 4.4. Une fois le service lanc\u00e9, v\u00e9rifiez bien que le wsdl est expos\u00e9, sur l'URL: http://localhost:8081/CountriesPortService/CountriesPortSoap11?wsdl","title":"1. Exposition d'un service web SOAP \u00e0 partir d'un fichier WSDL existant"},{"location":"tp1/#2-test-du-service-web-avec-soap-ui","text":"Nous allons maintenant tester notre service web. Comme vous le savez certainement, pour tester un service web SOAP, il faut \u00e9crire une SOAP Request (en XML), pour obtenir un SOAP Response de la part du service. Pour cela, nous utilisons un outil de test l\u00e9ger, appel\u00e9 SOAP UI. Lancer SOAP UI, et cr\u00e9er un nouveau projet SOAP. Ensuite: Nommer le projet TP1 par exemple. Coller l'URL du WSDL dans le champs Initial WSDL Dans le projet cr\u00e9\u00e9, naviguer vers TP1 -> CountriesPortSoap11 -> getCountry -> Request1 et double cliquer dessus. Une fen\u00eatre s'ouvre, comme suit: Pour tester le service, il suffit de remplacer le ? dans la balise ? par le nom d'un pays, par exemple Spain . Lancer le service en cliquant sur la fl\u00e8che verte. Que constatez-vous? Bien entendu, rien ne va vraiment se passer, car le service n'a pas encore \u00e9t\u00e9 impl\u00e9ment\u00e9. Tout ce qu'on a fait, c'est de donner une sp\u00e9cification vide. La r\u00e9ponse qui s'affiche est un fichier XML affichant une erreur semblable \u00e0 la suivante: Operation [getCountry:\\soapkit-config] not implemented . Nous allons montrer dans ce qui suit comment corriger cette erreur, pour afficher les informations d'un pays donn\u00e9 en param\u00e8tre.","title":"2. Test du service web avec SOAP UI"},{"location":"tp1/#3-implementation-du-service","text":"Le deuxi\u00e8me rectangle dans la fen\u00eatre principale de Anypoint permet de d\u00e9finir le comportement du service suite \u00e0 la r\u00e9ception d'un SOAP Request. Il contient pour le moment un seul composant : Transform Message . En cliquant dessus, vous retrouverez dans l'output le message d'erreur qui vous a \u00e9t\u00e9 retourn\u00e9 pr\u00e9c\u00e9demment. Ceci veut dire que le comportement du service n'a pas \u00e9t\u00e9 impl\u00e9ment\u00e9. Pour le faire, nous allons suivre les \u00e9tapes suivantes: Cliquer sur le composant Transform Message . Dans ses propri\u00e9t\u00e9s, trois colonnes sont affich\u00e9es tel que repr\u00e9sent\u00e9 dans la figure suivante: - Input: le squelette de la SOAP Request - Output (graphique): le squelette de la SOAP Response. - Output (code): le code XML correspondant \u00e0 la SOAP Response. Supprimer le bloc Soap#Fault du code XML. Glisser la variable name de l'Input vers la variable name de l'output graphique. Observez comment le code XML a \u00e9galement chang\u00e9. Double cliquer sur le champs population dans la colonne dde l'output graphique. Le code appropri\u00e9 sera g\u00e9n\u00e9r\u00e9 dans le XML. Remplacer la valeur null par la valeur de la population en Espagne (47420000 \u00e0 ce jour). Faites de m\u00eame pour indiquer la capitale ( Madrid ) et la monnaie ( EUR ). Le r\u00e9sultat devra ressembler \u00e0 ce qui suit: Relancer le service si vous l'avez ferm\u00e9, et observez le r\u00e9sultat sur SOAPUI. Cela a l'air de bien marcher! Cela dit, le service donnera toujours le m\u00eame r\u00e9sultat (population/capitale/monnaie), quelque soit l'input saisi dans pays. Nous allons essayer dans ce qui suit de le rendre un peu plus flexible, toujours sans \u00e9crire une ligne de code!","title":"3. Impl\u00e9mentation du service"},{"location":"tp1/#4-implementation-dune-condition","text":"Pour impl\u00e9menter une condition dans notre service, qui donne un output diff\u00e9rent selon l'entr\u00e9e qui lui est donn\u00e9e, nous allons suivre les \u00e9tapes suivantes: Nous allons d'abord cr\u00e9er une variable country , qu'on va alimenter \u00e0 partir de l'input. Pour cela: Glisser le composant Set Variable de la palette juste avant Transform Message Donner le nom country \u00e0 la variable. Dans le champ Value , cliquer sur le bouton . \u00c9crire quelque chose dans le champ qui s'affiche (par exemple country ) Cliquer ensuite sur le bouton pour mapper l'entr\u00e9e \u00e0 la variable. Dans la fen\u00eatre qui s'affiche, glisser l'\u00e9l\u00e9ment name de la requ\u00eate vers la chaine String (dans l'output graphique). La valeur que vous avez saisi sera \u00e9cras\u00e9e par l'expression du nom en entr\u00e9e. Cliquer sur Done \u00c0 partir de la palette, glisser le composant Choice avant Transform Message Glisser ensuite Transform Message dans le When Cliquer sur le When pour d\u00e9finir la condition. Dans le champ Expression , cliquer sur le bouton , puis taper directement la condition: vars.country == 'Spain' Pour ajouter une autre condition (un else if ), glisser un nouveau Transform Message de la palette vers l'extr\u00e9mit\u00e9 droite du box Choice . Refaire ensuite les op\u00e9rations pr\u00e9c\u00e9dentes pour un autre pays, tel que la Tunisie. Dans le box Default , cr\u00e9er un message d'erreur qui ressemble \u00e0 celui qu'on avait \u00e0 la cr\u00e9ation du service, qui indique que le pays donn\u00e9 en entr\u00e9e n'est pas pris en charge. Lancer le service, et v\u00e9rifier avec SOAPUI que toutes les conditions sont bien prises en compte. Attention Prenez des imprim-\u00e9crans d\u00e8s que a marche, vous en aurez besoin dans le rapport!","title":"4. Impl\u00e9mentation d'une condition"},{"location":"tp1/#consultation-dune-base-de-donnees","text":"Nous allons montrer dans ce qui suit les \u00e9tapes n\u00e9cessaires pour configurer et faire appel \u00e0 une base de donn\u00e9es. Nous allons utiliser MySQL dans notre exemple.","title":"Consultation d'une base de donn\u00e9es"},{"location":"tp1/#1-creation-et-population-de-la-base","text":"Pour cela: Cr\u00e9er une nouvelle base de donn\u00e9es avec MySQL. On l'appellera Countries. Lancer le script SQL suivant pour cr\u00e9er la table countries popul\u00e9e avec plusieurs exemples de pays: Consulter votre base pour voir son contenu et sa structure.","title":"1. Cr\u00e9ation et population de la base"},{"location":"tp1/#2-modification-du-flux","text":"Modifier le flux getCountry de fa\u00e7on \u00e0 ce qu'il ressemble \u00e0 l'image suivante: Set Variable permet de cr\u00e9er une variable country qui saisit l'entr\u00e9e dans la SOAP Request. Logger permet d'afficher le contenu de la variable saisie sur la console, sous la forme: \"Pays: <nom_pays>\" . Select contient la requ\u00eate de s\u00e9lection de la base de donn\u00e9es, filtr\u00e9e par le pays donn\u00e9 en entr\u00e9e. Transform Message retourne dans la SOAP Response, les informations du pays en entr\u00e9e, extraites de la base de donn\u00e9es. Le r\u00e9sultat attendu ressemble au suivant:","title":"2. Modification du flux"},{"location":"tp1/#projet","text":"\u00c9tape 1 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 1 du projet, qui consiste \u00e0: Trouver le concept de votre entreprise (nom, logo, m\u00e9tier, et d\u00e9partements) R\u00e9aliser le tutoriel : Archisurance (voir les supports du projet) Commencer \u00e0 r\u00e9aliser les diagrammes de votre propre entreprise.","title":"Projet"},{"location":"tp2-old/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Routage, m\u00e9diation et transformation avec Talend ESB. Gestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB. Outils et Versions \u00b6 Talend Open Studio for ESB Version: 8.0.1 DBeaver Community Version 22.2.1 Configuration et Utilisation de l'ESB Talend \u00b6 Lancement de deux instances de l'ESB Talend \u00b6 Pour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire: Aller dans le r\u00e9pertoire <rep_install_talend>/Runtime_ESBSE Copier le r\u00e9pertoire container et le renommer en alternate-container . Nous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans alternate-container ) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela: Lancer l\u2019ESB : dans le r\u00e9pertoire alternate-container que vous venez de cr\u00e9er, aller vers bin et ex\u00e9cuter trun.bash (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire alternate-container/bin et lancer dans un terminal la commande ./trun . La fen\u00eatre suivante devrait s\u2019afficher: Attention Il faudra peut-\u00eatre downgrader votre version de Java si vous \u00eates sur la 17 (la version recommand\u00e9e ici est la 11).. sorry Le premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante. Configurer l'ESB : dans l\u2019invite de commande affich\u00e9e, taper: source scripts/configureC1.sh Un affichage tel que le suivant va appara\u00eetre: Vous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh. Arr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau. Lancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040. Publier votre Service dans l'ESB et le Tester \u00b6 Revenir au service web SOAP HelloWorldService que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur Talend Open Studio sur le projet Helloworld , et suivre les \u00e9tapes suivantes: Faire un clic-droit sur le service HelloWorldService et choisir Exporter le service . Choisir comme r\u00e9pertoire de destination le dossier deploy se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB). D\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9. V\u00e9rifier que vos services sont actifs: en tapant list dans vos deux instances d\u2019ESB en affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090. Pour tester votre service web: Dans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040 Lancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB. V\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci: Cr\u00e9ation des Routes \u00b6 Les routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires. Premi\u00e8re Route: Filtrage des Messages \u00b6 Cr\u00e9er une nouvelle route en cliquant-droit sur Routes -> Cr\u00e9er une Route . Nous allons l\u2019appeler FiltrageRoute. D\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit: Les composants utilis\u00e9s sont: cSOAP : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS. MessageRouter : route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es. Configurer la condition when , en pr\u00e9cisant que c\u2019est une condition de type simple , dont le texte est : \" ${ bodyAs (String) } contains 'Alice'\" Cela veut dire que, si le corps du message contient Alice , la requ\u00eate sera rout\u00e9e vers le composant cSOAP_2 . Configurer le composant cSOAP_1: Adresse: http://localhost:8042/services/HelloWorldService WSDL: http://localhost:8040/services/HelloWorldService?WSDL . Remarque Remarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB. Configurer l\u2019adresse de cSOAP_2 sur le port 8040, et celle de cSOAP_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants. Lancer la route pour la tester. La console devra afficher connected . Pour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous? Erreur possible: java.lang.NoClassDefFoundError Dans le cas d'une erreur de type java.lang.NoClassDefFoundError , v\u00e9rifier que tous les modules n\u00e9cessaires sont bien t\u00e9l\u00e9charg\u00e9s. Pour cela: Ouvrir _Window -> Show View... -> Modules V\u00e9rifier qu'il n'y a pas de modules n\u00e9cessaires non t\u00e9l\u00e9charg\u00e9s (leur statut est Not Installed avec une ic\u00f4ne de type ou ). Si vous en trouvez, t\u00e9l\u00e9chargez leur jar manuellement sur internet, et ajoutez-le au projet en cliquant sur le symbole du jar, comme indiqu\u00e9 dans la figure suivante: D\u00e9ploiement des Routes sur l'ESB \u00b6 Dans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes: Faites un clic-droit sur votre route et s\u00e9lectionner: Build Route (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9). Choisir le r\u00e9pertoire deploy du conteneur de votre choix. Tester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur. Attention Vous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse. Deuxi\u00e8me Route : Filtrage et Modification de Messages \u00b6 Dans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela: Dans Talend Studio, dupliquer votre route FiltrageRoute et la nommer ModificationRoute . Ins\u00e9rer un composant cSetBody (permettant de modifier le corps du message re\u00e7u) puis un composant cProcessor (permettant de remanier rapidement du code dans la route) entre le cMessageRouter et le cSOAP_3 . Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant: Ins\u00e9rer le code suivant (de type Xpath) dans le cSetBody : \"tns:HelloWorldServiceOperationRequest/in\" Ceci permet de saisir le contenu de la balise in de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace tns ( http://www.talend.org/service/ ). Ins\u00e9rer le code suivant dans le processeur: String name = exchange . getIn (). getBody ( String . class ); String surname ; if ( name . contains ( \"Bob\" )){ surname = \"Bobby\" ; } else { surname = \"Chucky\" ; } exchange . getIn (). setBody ( \"<tns:HelloWorldServiceOperationRequest \" + \"xmlns:tns=\\\"http://www.talend.org/service/\\\"><in>\" + surname + \"</in> </tns:HelloWorldServiceOperationRequest>\" ); Ce code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom. Modifier l'adresse du composant cSOAP_1 pour qu'il se lance sur le port 8043. Sauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat. Fonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB \u00b6 Failover et R\u00e9partition de Charge \u00b6 Service Locator \u00b6 Via le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs). Configuration du Service Locator \u00b6 Pour activer le service locator (SL), il faut: D\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend Activer la prise en compte du SL au niveau du service cible Configurer le consommateur du service pour prendre en compte le SL 1. D\u00e9ploiement du SL dans le contenaire \u00b6 Pour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB: tesb : start-locator Il est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes: 2. Activer SL dans le service \u00b6 Pour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio: Clic-droit sur le service Choisir ESB Runtime Options Cocher la case \"Utiliser le Service Locator\" Il faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9. 3. Activer SL dans le consommateur \u00b6 Au niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case Use Service Locator . Test du Service Locator \u00b6 Pour tester la r\u00e9partition de charges* : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat. Pour tester la gestion du failover* : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper list , puis chercher l'identifiant du service HelloWorldService . Taper ensuite : stop <id_service> . Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat. Service Monitoring \u00b6 Le composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes. Pour configurer le Service Activity Monitoring: D\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper : tesb : start-sam Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services. Activer la prise en compte de SAM au niveau du service cible Configurer le consommateur du service pour prendre en compte le SAM Pour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que DBeaver . Pour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants: Database connection configuration : Derby Server Driver : Derby Server Database Server : localhost Database Port : 1527 Database : DB DB username : test DB password : test Ex\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat. Authentification \u00b6 Security Token Service (STS) : Impl\u00e9mentation du WS-Trust \u00b6 Dans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust. \"Trust\" veut dire \"Confiance\" : le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur. Pour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service. Le STS ( Security Token Service ) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes: D\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s. V\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification Renouveler un jeton de s\u00e9curit\u00e9 Annuler un jeton de s\u00e9curit\u00e9 Transformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent. L\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames. Configuration des Param\u00e8tres de S\u00e9curit\u00e9 \u00b6 Pour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes: D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur Activer la prise en compte de STS dans votre service Configurer votre client pour saisir les param\u00e8tres d\u2019authentification. 1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution \u00b6 Pour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal: feature : install tesb-sts Si le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande : list . Vous devriez trouver les lignes suivantes: 2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur \u00b6 Comme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame. Pour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier: <conteneur>/etc/users.properties . Dans ce fichier, les informations d'authentification sont sous la forme: user=password,group . Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe admin . 3. Activer STS dans votre service \u00b6 Pour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans ESB Runtime Options , cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas, Identifiant/Mot de passe ) 4. Configurer le client \u00b6 Pour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur. Homework \u00b6 Projet E2 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 2 du projet, qui consiste \u00e0: Terminer les diagrammes de votre entreprise commenc\u00e9s la semaine d'avant. Concevoir et commencer l'impl\u00e9mentation des services n\u00e9cessaires pour votre PoC. R\u00e9fl\u00e9chir \u00e0 l'usage des ESB, leur r\u00f4le et les strat\u00e9gies qui y seront impl\u00e9ment\u00e9es.","title":"Tp2 old"},{"location":"tp2-old/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp2-old/#objectifs-du-tp","text":"Routage, m\u00e9diation et transformation avec Talend ESB. Gestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB.","title":"Objectifs du TP"},{"location":"tp2-old/#outils-et-versions","text":"Talend Open Studio for ESB Version: 8.0.1 DBeaver Community Version 22.2.1","title":"Outils et Versions"},{"location":"tp2-old/#configuration-et-utilisation-de-lesb-talend","text":"","title":"Configuration et Utilisation de l'ESB Talend"},{"location":"tp2-old/#lancement-de-deux-instances-de-lesb-talend","text":"Pour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire: Aller dans le r\u00e9pertoire <rep_install_talend>/Runtime_ESBSE Copier le r\u00e9pertoire container et le renommer en alternate-container . Nous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans alternate-container ) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela: Lancer l\u2019ESB : dans le r\u00e9pertoire alternate-container que vous venez de cr\u00e9er, aller vers bin et ex\u00e9cuter trun.bash (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire alternate-container/bin et lancer dans un terminal la commande ./trun . La fen\u00eatre suivante devrait s\u2019afficher: Attention Il faudra peut-\u00eatre downgrader votre version de Java si vous \u00eates sur la 17 (la version recommand\u00e9e ici est la 11).. sorry Le premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante. Configurer l'ESB : dans l\u2019invite de commande affich\u00e9e, taper: source scripts/configureC1.sh Un affichage tel que le suivant va appara\u00eetre: Vous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh. Arr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau. Lancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040.","title":"Lancement de deux instances de l'ESB Talend"},{"location":"tp2-old/#publier-votre-service-dans-lesb-et-le-tester","text":"Revenir au service web SOAP HelloWorldService que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur Talend Open Studio sur le projet Helloworld , et suivre les \u00e9tapes suivantes: Faire un clic-droit sur le service HelloWorldService et choisir Exporter le service . Choisir comme r\u00e9pertoire de destination le dossier deploy se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB). D\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9. V\u00e9rifier que vos services sont actifs: en tapant list dans vos deux instances d\u2019ESB en affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090. Pour tester votre service web: Dans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040 Lancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB. V\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci:","title":"Publier votre Service dans l'ESB et le Tester"},{"location":"tp2-old/#creation-des-routes","text":"Les routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires.","title":"Cr\u00e9ation des Routes"},{"location":"tp2-old/#premiere-route-filtrage-des-messages","text":"Cr\u00e9er une nouvelle route en cliquant-droit sur Routes -> Cr\u00e9er une Route . Nous allons l\u2019appeler FiltrageRoute. D\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit: Les composants utilis\u00e9s sont: cSOAP : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS. MessageRouter : route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es. Configurer la condition when , en pr\u00e9cisant que c\u2019est une condition de type simple , dont le texte est : \" ${ bodyAs (String) } contains 'Alice'\" Cela veut dire que, si le corps du message contient Alice , la requ\u00eate sera rout\u00e9e vers le composant cSOAP_2 . Configurer le composant cSOAP_1: Adresse: http://localhost:8042/services/HelloWorldService WSDL: http://localhost:8040/services/HelloWorldService?WSDL . Remarque Remarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB. Configurer l\u2019adresse de cSOAP_2 sur le port 8040, et celle de cSOAP_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants. Lancer la route pour la tester. La console devra afficher connected . Pour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous? Erreur possible: java.lang.NoClassDefFoundError Dans le cas d'une erreur de type java.lang.NoClassDefFoundError , v\u00e9rifier que tous les modules n\u00e9cessaires sont bien t\u00e9l\u00e9charg\u00e9s. Pour cela: Ouvrir _Window -> Show View... -> Modules V\u00e9rifier qu'il n'y a pas de modules n\u00e9cessaires non t\u00e9l\u00e9charg\u00e9s (leur statut est Not Installed avec une ic\u00f4ne de type ou ). Si vous en trouvez, t\u00e9l\u00e9chargez leur jar manuellement sur internet, et ajoutez-le au projet en cliquant sur le symbole du jar, comme indiqu\u00e9 dans la figure suivante:","title":"Premi\u00e8re Route: Filtrage des Messages"},{"location":"tp2-old/#deploiement-des-routes-sur-lesb","text":"Dans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes: Faites un clic-droit sur votre route et s\u00e9lectionner: Build Route (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9). Choisir le r\u00e9pertoire deploy du conteneur de votre choix. Tester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur. Attention Vous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse.","title":"D\u00e9ploiement des Routes sur l'ESB"},{"location":"tp2-old/#deuxieme-route-filtrage-et-modification-de-messages","text":"Dans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela: Dans Talend Studio, dupliquer votre route FiltrageRoute et la nommer ModificationRoute . Ins\u00e9rer un composant cSetBody (permettant de modifier le corps du message re\u00e7u) puis un composant cProcessor (permettant de remanier rapidement du code dans la route) entre le cMessageRouter et le cSOAP_3 . Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant: Ins\u00e9rer le code suivant (de type Xpath) dans le cSetBody : \"tns:HelloWorldServiceOperationRequest/in\" Ceci permet de saisir le contenu de la balise in de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace tns ( http://www.talend.org/service/ ). Ins\u00e9rer le code suivant dans le processeur: String name = exchange . getIn (). getBody ( String . class ); String surname ; if ( name . contains ( \"Bob\" )){ surname = \"Bobby\" ; } else { surname = \"Chucky\" ; } exchange . getIn (). setBody ( \"<tns:HelloWorldServiceOperationRequest \" + \"xmlns:tns=\\\"http://www.talend.org/service/\\\"><in>\" + surname + \"</in> </tns:HelloWorldServiceOperationRequest>\" ); Ce code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom. Modifier l'adresse du composant cSOAP_1 pour qu'il se lance sur le port 8043. Sauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat.","title":"Deuxi\u00e8me Route : Filtrage et Modification de Messages"},{"location":"tp2-old/#fonctionnalites-supplementaires-de-lesb","text":"","title":"Fonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB"},{"location":"tp2-old/#failover-et-repartition-de-charge","text":"","title":"Failover et R\u00e9partition de Charge"},{"location":"tp2-old/#service-locator","text":"Via le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs).","title":"Service Locator"},{"location":"tp2-old/#configuration-du-service-locator","text":"Pour activer le service locator (SL), il faut: D\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend Activer la prise en compte du SL au niveau du service cible Configurer le consommateur du service pour prendre en compte le SL","title":"Configuration du Service Locator"},{"location":"tp2-old/#1-deploiement-du-sl-dans-le-contenaire","text":"Pour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB: tesb : start-locator Il est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes:","title":"1. D\u00e9ploiement du SL dans le contenaire"},{"location":"tp2-old/#2-activer-sl-dans-le-service","text":"Pour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio: Clic-droit sur le service Choisir ESB Runtime Options Cocher la case \"Utiliser le Service Locator\" Il faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9.","title":"2. Activer SL dans le service"},{"location":"tp2-old/#3-activer-sl-dans-le-consommateur","text":"Au niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case Use Service Locator .","title":"3. Activer SL dans le consommateur"},{"location":"tp2-old/#test-du-service-locator","text":"Pour tester la r\u00e9partition de charges* : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat. Pour tester la gestion du failover* : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper list , puis chercher l'identifiant du service HelloWorldService . Taper ensuite : stop <id_service> . Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat.","title":"Test du Service Locator"},{"location":"tp2-old/#service-monitoring","text":"Le composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes. Pour configurer le Service Activity Monitoring: D\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper : tesb : start-sam Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services. Activer la prise en compte de SAM au niveau du service cible Configurer le consommateur du service pour prendre en compte le SAM Pour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que DBeaver . Pour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants: Database connection configuration : Derby Server Driver : Derby Server Database Server : localhost Database Port : 1527 Database : DB DB username : test DB password : test Ex\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat.","title":"Service Monitoring"},{"location":"tp2-old/#authentification","text":"","title":"Authentification"},{"location":"tp2-old/#security-token-service-sts-implementation-du-ws-trust","text":"Dans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust. \"Trust\" veut dire \"Confiance\" : le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur. Pour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service. Le STS ( Security Token Service ) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes: D\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s. V\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification Renouveler un jeton de s\u00e9curit\u00e9 Annuler un jeton de s\u00e9curit\u00e9 Transformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent. L\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames.","title":"Security Token Service (STS) : Impl\u00e9mentation du WS-Trust"},{"location":"tp2-old/#configuration-des-parametres-de-securite","text":"Pour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes: D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur Activer la prise en compte de STS dans votre service Configurer votre client pour saisir les param\u00e8tres d\u2019authentification.","title":"Configuration des Param\u00e8tres de S\u00e9curit\u00e9"},{"location":"tp2-old/#1-deployer-sts-dans-le-conteneur-dexecution","text":"Pour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal: feature : install tesb-sts Si le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande : list . Vous devriez trouver les lignes suivantes:","title":"1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution"},{"location":"tp2-old/#2-configurer-les-parametres-de-securite-de-votre-conteneur","text":"Comme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame. Pour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier: <conteneur>/etc/users.properties . Dans ce fichier, les informations d'authentification sont sous la forme: user=password,group . Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe admin .","title":"2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur"},{"location":"tp2-old/#3-activer-sts-dans-votre-service","text":"Pour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans ESB Runtime Options , cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas, Identifiant/Mot de passe )","title":"3. Activer STS dans votre service"},{"location":"tp2-old/#4-configurer-le-client","text":"Pour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur.","title":"4. Configurer le client"},{"location":"tp2-old/#homework","text":"Projet E2 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 2 du projet, qui consiste \u00e0: Terminer les diagrammes de votre entreprise commenc\u00e9s la semaine d'avant. Concevoir et commencer l'impl\u00e9mentation des services n\u00e9cessaires pour votre PoC. R\u00e9fl\u00e9chir \u00e0 l'usage des ESB, leur r\u00f4le et les strat\u00e9gies qui y seront impl\u00e9ment\u00e9es.","title":"Homework"},{"location":"tp2/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 G\u00e9n\u00e9ration d\u2019API avec Anypoint API Designer et le langage RAML Gestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft Outils et Versions \u00b6 Anypoint Studio 7 and Mule ESB 4 MySQL Version latest Dans ce TP, nous aurons besoin du service SOAP cr\u00e9\u00e9 dans le TP1 . API Management avec Anypoint Studio \u00b6 G\u00e9n\u00e9ration d'API avec RAML \u00b6 RAML \u00b6 RAML (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful. RAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles technologies, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage. Cr\u00e9ation de l'API RAML avec AnyPoint API Designer \u00b6 Pour \u00e9crire un document RAML, ouvrir Anypoint Studio, et cr\u00e9er un nouveau projet de type \"API Specification Project\" , intitul\u00e9 CountriesAPI de type RAML 1.0 . L'interface suivante devra s'afficher: Cr\u00e9ation d\u2019un document RAML \u00b6 Dans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations de bonne conception d'API REST. Cr\u00e9ation d\u2019une API RAML \u00b6 Remplir le fichier countriesapi.raml cr\u00e9\u00e9 pour qu'il ressemble \u00e0 ce qui suit: #%RAML 1.0 title : Countries version : v1 baseUri : /countries /countries : get : responses : 200 : body : application/json : properties : name : string population : number capital : string currency : string post : body : application/json : properties : name : string population : number capital : string currency : string /{id} : delete : responses : 204 : put : body : application/json : properties : name : string population : number capital : string currency : string Attention! Prenez soin de respecter les tabulations et les retraits de ligne! Dans cette description, nous d\u00e9finissons le comportement principal de l'API, \u00e0 l'appel des quatre m\u00e9thodes les plus fr\u00e9quentes: un GET ou un POST sur la ressource principale, et un DELETE ou un PUT sur un objet particulier repr\u00e9sent\u00e9 par son id . D\u00e9finir des types \u00b6 Pour \u00e9viter les redondances constat\u00e9es dans notre d\u00e9finition, nous cr\u00e9ons le type Country . Pour cela: Dans une nouvelle ligne au dessus de /countries , taper les lignes suivantes: types : Country : properties : name : string population : number capital : string currency : string D\u00e9finir Country comme type pour le corps de la m\u00e9thode post , en \u00e9crivant: type: Country au dessous de application/json de la m\u00e9thode post Ajouter de m\u00eame Country comme type pour la m\u00e9thode put, et Country[] pour la m\u00e9thode get. Extraction d\u2019un type de ressources \u00b6 Pour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante: Ajouter le code suivant au dessus du title : resourceTypes : Collection : get : responses : 200 : body : application/json : type : Country[] post : body : application/json : type : Country Member : delete : responses : 204 : put : body : application/json : type : Country Supprimer le contenu de /countries et de /{id} pour le remplacer par les nouveaux resourceTypes d\u00e9finis en utilisant: type: Collection et type: Member . Ajout de param\u00e8tres au type de ressource \u00b6 Pour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela: Remplacer le terme Country dans Collection et Member par <<item>> . Remplacer les ressources Collection et Member respectivement par { Collection: {item : Country} } et { Member: {item : Country} } Ajout d\u2019un exemple \u00b6 Pour ajouter un exemple de pays, modifier le type Country pour qu\u2019il soit comme suit: types : Country : properties : name : string population : number capital : string currency : string example : name : Spain population : 46704314 capital : Madrid currency : EUR Cr\u00e9ation du service REST avec APIKit \u00b6 APIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs. Nous allons commencer par impl\u00e9menter l'API REST que nous venons de cr\u00e9er avec RAML de faon statique, puis en faisant appel au service SOAP cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent. Cr\u00e9ation du projet REST dans Mule \u00b6 Cr\u00e9er un nouveau Mule Project qu\u2019on appellera CountriesRESTService : Choisir comme environnement d\u2019ex\u00e9cution Mule Server. Cliquer sur l'onglet Import RAML from local file et choisir le fichier countriesapi.raml cr\u00e9\u00e9 dans la premi\u00e8re partie du TP. Un nouveau projet sera cr\u00e9\u00e9 avec le fichiers countriesapi.raml sous le r\u00e9pertoire src/main/resources/api , ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment: Flux Description Figure countriesapi-main Flux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception action:/ressource:api-config Un Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products Configuration du flux principal \u00b6 Dans les propri\u00e9t\u00e9s du composant Listener du flux principal ( countriesapi-main ), on peut constater que le chemin principal de l'api, repr\u00e9sent\u00e9 par le Path, est : /api/* . Dans le Connector Configuration , cliquer sur l'ic\u00f4ne , modifier le port en 8088 pour \u00e9viter les conflits futurs avec le service SOAP du TP pr\u00e9c\u00e9dent, puis cliquer sur OK . Lancer le projet comme Mule Application . Pour commencer, afficher la documentation de l'API dans une APIKit Console . Pour cela: Aller \u00e0 Window -> Show View -> Other... Choisir APIKit View -> APIKit Consoles Une vue va s'afficher comme suit (regardez \u00e0 gauche de l'\u00e9cran): Cliquer sur Open Console . Une fen\u00eatre va s'afficher sur votre navigateur, comme suit: Pour consulter votre API, cliquer par exemple sur le bouton GET de la ressource /countries . La console affichera alors la r\u00e9ponse, qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part. Impl\u00e9mentation du service statiquement dans Mule \u00b6 Nous allons impl\u00e9menter la m\u00e9thode get du service pour qu'elle extrait les donn\u00e9es \u00e0 partir de la base de donn\u00e9es MySQL Countries cr\u00e9\u00e9e dans le TP pr\u00e9c\u00e9dent. Pour cela, reconstruire le flux get:\\countries de fa\u00e7on \u00e0 obtenir le r\u00e9sultat suivant: Pour tester que votre requ\u00eate fonctionne bien, il suffit de taper le chemin suivant sur votre navigateur (ou tout autre outil de test REST: http://localhost:8088/api/countries . Si tout se passe bien, le r\u00e9sultat devrait ressembler \u00e0 ce qui suit: [ { capi tal : \"Yerevan\" , na me : \"Armenia\" , curre n cy : \"AMD\" , popula t io n : 3000000 }, { capi tal : \"Berlin\" , na me : \"Germany\" , curre n cy : \"EUR\" , popula t io n : 83000000 }, { capi tal : \"Warsaw\" , na me : \"Poland\" , curre n cy : \"PLN\" , popula t io n : 38000000 }, { capi tal : \"Moscow\" , na me : \"Russia\" , curre n cy : \"RUB\" , popula t io n : 145000000 }, { capi tal : \"Madrid\" , na me : \"Spain\" , curre n cy : \"EUR\" , popula t io n : 47420000 }, { capi tal : \"Tunis\" , na me : \"Tunisia\" , curre n cy : \"TND\" , popula t io n : 12260000 } ] Appel au service SOAP du TP1 \u00e0 partir de l'API REST \u00b6 L'une des grandes utilit\u00e9s d'un ESB est d'int\u00e9grer les services existants qui utilisent parfois des protocoles ou technologies diff\u00e9rentes. Nous allons montrer comment on pourra, avec notre service REST, faire appel \u00e0 un service SOAP. On rappelle que le service SOAP cr\u00e9\u00e9 pr\u00e9c\u00e9demment, prend en entr\u00e9e le nom d'un pays (param\u00e8tre name de type cha\u00eene de caract\u00e8res), et retourne une SOAP Response avec les informations relatives \u00e0 ce pays, extraites de la base de donn\u00e9es countries . Modifier le RAML initial \u00b6 Nous devons modifier le fichier RAML initial de fa\u00e7on \u00e0 exposer une m\u00e9thode get qui prend en entr\u00e9e un nom de pays. Pour cela: Ouvrir le fichier RAML dans le projet countriesrestservice (vous le trouverez sous src/main/resources/api ), et ajouter, sous Member , l'\u00e9l\u00e9ment suivant: get : responses : 200 : body : application/json : type : <<item>> Pour recharger le nouveau fichier et g\u00e9n\u00e9rer le flux que nous venons de cr\u00e9er, faire un clic-droit sur le projet, et choisir Mule -> Generate Flows from Local REST API . Vous remarquerez que le flux suivant vient d'\u00eatre ajout\u00e9: Nous commencerons par tester ce service. Pour cela, dans le second Transform Message , glisser-d\u00e9placer la variable id vers la sortie name , comme suit: Relancer ce service, et observer le r\u00e9sultat en tapant le chemin http://localhost:8088/api/countries/Dorne . L'affichage est bien s\u00fbr incongru, mais \u00e7a fonctionne s'il vous donne \u00e7a: { na me : \"SpainDorne\" , popula t io n : 46704314 , capi tal : \"Madrid\" , curre n cy : \"EUR\" } Appeler le service SOAP \u00b6 Pour appeler votre service SOAP, modifier le flux de la requ\u00eate get:\\countries(id) comme suit: Supprimer tous les composants d\u00e9j\u00e0 existants. Ajouter le composant Web Service Consumer . Le configurer comme suit: Devant Connector configuration , cliquer sur pour ajouter une nouvelle configuration. Coller le chemin du WSDL de votre service SOAP dans WSDL Location (si vous n'avez rien chang\u00e9, cela devrait \u00eatre http://localhost:8081/CountriesPortService/CountriesPortSoap11?wsdl ) Cliquer sur OK pour valider. Les valeurs suivantes devraient s'afficher : Service : CountriesPortService Port : CountriesPortSoap11 Address : http://localhost:8081/CountriesPortService/CountriesPortSoap11 Une fois cette fen\u00eatre ferm\u00e9e, s\u00e9lectionner (si ce n'est d\u00e9j\u00e0 fait) getCountry dans Operation. Dans la partie Body, cliquer sur le bouton pour mapper l'entr\u00e9e du service REST \u00e0 celui du service SOAP. Glisser-d\u00e9placer ensuite la variable id se trouvant sous Attributes -> uriParams de la fen\u00eatre de gauche, vers la variable name se trouvant sous getCountryRequest de la fen\u00eatre de droite. Le code suivant devrait se g\u00e9n\u00e9rer : output application/xml ns ns0 http : //spring.io/guides/gs-producing-web-service --- { ns0#getCountryRequest : { ns0#name : attributes.uriParams.id } } Ajouter maintenant le composant Transform Message pour transformer la r\u00e9ponse SOAP re\u00e7ue en JSON. Glisser-d\u00e9placer les champs provenant du payload getCountryResponse vers l'objet en sortie. Cela devra g\u00e9n\u00e9rer le code suivant: %dw 2.0 output application/json ns ns0 http : //spring.io/guides/gs-producing-web-service --- { capital : payload.body.ns0#getCountryResponse.ns0#country.ns0#capital default \"\", name : payload.body.ns0#getCountryResponse.ns0#country.ns0#name default \"\", currency : payload.body.ns0#getCountryResponse.ns0#country.ns0#currency default \"\", population : payload.body.ns0#getCountryResponse.ns0#country.ns0#population default 0 } Lancer les services \u00b6 Pour ex\u00e9cuter les deux services dans Anypoint, il faut suivre les \u00e9tapes suivantes: Cr\u00e9er une nouvelle configuration d'ex\u00e9cution ( Run Configurations... ) qu'on appellera services1and2 S\u00e9lectionner les deux services tp1 et countriesrestservice . Cela devra ressembler \u00e0 ce qui suit: Lancer les deux services en cliquant sur Run . Une fois les deux services lanc\u00e9s, tester la nouvelle fonctionnalit\u00e9 impl\u00e9ment\u00e9e, en allant sur le navigateur et en testant par exemple: http://localhost:8088/api/countries/Armenia . Le r\u00e9sultat affich\u00e9 sera ainsi: Projet \u00b6 \u00c9tape 2 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 2 du projet, qui consiste \u00e0: Terminer les diagrammes de votre entreprise commenc\u00e9s la semaine d'avant. Concevoir et commencer l'impl\u00e9mentation des services n\u00e9cessaires pour votre PoC. R\u00e9fl\u00e9chir \u00e0 l'usage des ESB, leur r\u00f4le et les strat\u00e9gies qui y seront impl\u00e9ment\u00e9es.","title":"TP2 - REST API Management avec Anypoint Studio"},{"location":"tp2/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp2/#objectifs-du-tp","text":"G\u00e9n\u00e9ration d\u2019API avec Anypoint API Designer et le langage RAML Gestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft","title":"Objectifs du TP"},{"location":"tp2/#outils-et-versions","text":"Anypoint Studio 7 and Mule ESB 4 MySQL Version latest Dans ce TP, nous aurons besoin du service SOAP cr\u00e9\u00e9 dans le TP1 .","title":"Outils et Versions"},{"location":"tp2/#api-management-avec-anypoint-studio","text":"","title":"API Management avec Anypoint Studio"},{"location":"tp2/#generation-dapi-avec-raml","text":"","title":"G\u00e9n\u00e9ration d'API avec RAML"},{"location":"tp2/#raml","text":"RAML (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful. RAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles technologies, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage.","title":"RAML"},{"location":"tp2/#creation-de-lapi-raml-avec-anypoint-api-designer","text":"Pour \u00e9crire un document RAML, ouvrir Anypoint Studio, et cr\u00e9er un nouveau projet de type \"API Specification Project\" , intitul\u00e9 CountriesAPI de type RAML 1.0 . L'interface suivante devra s'afficher:","title":"Cr\u00e9ation de l'API RAML avec AnyPoint API Designer"},{"location":"tp2/#creation-dun-document-raml","text":"Dans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations de bonne conception d'API REST.","title":"Cr\u00e9ation d\u2019un document RAML"},{"location":"tp2/#creation-dune-api-raml","text":"Remplir le fichier countriesapi.raml cr\u00e9\u00e9 pour qu'il ressemble \u00e0 ce qui suit: #%RAML 1.0 title : Countries version : v1 baseUri : /countries /countries : get : responses : 200 : body : application/json : properties : name : string population : number capital : string currency : string post : body : application/json : properties : name : string population : number capital : string currency : string /{id} : delete : responses : 204 : put : body : application/json : properties : name : string population : number capital : string currency : string Attention! Prenez soin de respecter les tabulations et les retraits de ligne! Dans cette description, nous d\u00e9finissons le comportement principal de l'API, \u00e0 l'appel des quatre m\u00e9thodes les plus fr\u00e9quentes: un GET ou un POST sur la ressource principale, et un DELETE ou un PUT sur un objet particulier repr\u00e9sent\u00e9 par son id .","title":"Cr\u00e9ation d\u2019une API RAML"},{"location":"tp2/#definir-des-types","text":"Pour \u00e9viter les redondances constat\u00e9es dans notre d\u00e9finition, nous cr\u00e9ons le type Country . Pour cela: Dans une nouvelle ligne au dessus de /countries , taper les lignes suivantes: types : Country : properties : name : string population : number capital : string currency : string D\u00e9finir Country comme type pour le corps de la m\u00e9thode post , en \u00e9crivant: type: Country au dessous de application/json de la m\u00e9thode post Ajouter de m\u00eame Country comme type pour la m\u00e9thode put, et Country[] pour la m\u00e9thode get.","title":"D\u00e9finir des types"},{"location":"tp2/#extraction-dun-type-de-ressources","text":"Pour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante: Ajouter le code suivant au dessus du title : resourceTypes : Collection : get : responses : 200 : body : application/json : type : Country[] post : body : application/json : type : Country Member : delete : responses : 204 : put : body : application/json : type : Country Supprimer le contenu de /countries et de /{id} pour le remplacer par les nouveaux resourceTypes d\u00e9finis en utilisant: type: Collection et type: Member .","title":"Extraction d\u2019un type de ressources"},{"location":"tp2/#ajout-de-parametres-au-type-de-ressource","text":"Pour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela: Remplacer le terme Country dans Collection et Member par <<item>> . Remplacer les ressources Collection et Member respectivement par { Collection: {item : Country} } et { Member: {item : Country} }","title":"Ajout de param\u00e8tres au type de ressource"},{"location":"tp2/#ajout-dun-exemple","text":"Pour ajouter un exemple de pays, modifier le type Country pour qu\u2019il soit comme suit: types : Country : properties : name : string population : number capital : string currency : string example : name : Spain population : 46704314 capital : Madrid currency : EUR","title":"Ajout d\u2019un exemple"},{"location":"tp2/#creation-du-service-rest-avec-apikit","text":"APIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs. Nous allons commencer par impl\u00e9menter l'API REST que nous venons de cr\u00e9er avec RAML de faon statique, puis en faisant appel au service SOAP cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent.","title":"Cr\u00e9ation du service REST avec APIKit"},{"location":"tp2/#creation-du-projet-rest-dans-mule","text":"Cr\u00e9er un nouveau Mule Project qu\u2019on appellera CountriesRESTService : Choisir comme environnement d\u2019ex\u00e9cution Mule Server. Cliquer sur l'onglet Import RAML from local file et choisir le fichier countriesapi.raml cr\u00e9\u00e9 dans la premi\u00e8re partie du TP. Un nouveau projet sera cr\u00e9\u00e9 avec le fichiers countriesapi.raml sous le r\u00e9pertoire src/main/resources/api , ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment: Flux Description Figure countriesapi-main Flux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception action:/ressource:api-config Un Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products","title":"Cr\u00e9ation du projet REST dans Mule"},{"location":"tp2/#configuration-du-flux-principal","text":"Dans les propri\u00e9t\u00e9s du composant Listener du flux principal ( countriesapi-main ), on peut constater que le chemin principal de l'api, repr\u00e9sent\u00e9 par le Path, est : /api/* . Dans le Connector Configuration , cliquer sur l'ic\u00f4ne , modifier le port en 8088 pour \u00e9viter les conflits futurs avec le service SOAP du TP pr\u00e9c\u00e9dent, puis cliquer sur OK . Lancer le projet comme Mule Application . Pour commencer, afficher la documentation de l'API dans une APIKit Console . Pour cela: Aller \u00e0 Window -> Show View -> Other... Choisir APIKit View -> APIKit Consoles Une vue va s'afficher comme suit (regardez \u00e0 gauche de l'\u00e9cran): Cliquer sur Open Console . Une fen\u00eatre va s'afficher sur votre navigateur, comme suit: Pour consulter votre API, cliquer par exemple sur le bouton GET de la ressource /countries . La console affichera alors la r\u00e9ponse, qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part.","title":"Configuration du flux principal"},{"location":"tp2/#implementation-du-service-statiquement-dans-mule","text":"Nous allons impl\u00e9menter la m\u00e9thode get du service pour qu'elle extrait les donn\u00e9es \u00e0 partir de la base de donn\u00e9es MySQL Countries cr\u00e9\u00e9e dans le TP pr\u00e9c\u00e9dent. Pour cela, reconstruire le flux get:\\countries de fa\u00e7on \u00e0 obtenir le r\u00e9sultat suivant: Pour tester que votre requ\u00eate fonctionne bien, il suffit de taper le chemin suivant sur votre navigateur (ou tout autre outil de test REST: http://localhost:8088/api/countries . Si tout se passe bien, le r\u00e9sultat devrait ressembler \u00e0 ce qui suit: [ { capi tal : \"Yerevan\" , na me : \"Armenia\" , curre n cy : \"AMD\" , popula t io n : 3000000 }, { capi tal : \"Berlin\" , na me : \"Germany\" , curre n cy : \"EUR\" , popula t io n : 83000000 }, { capi tal : \"Warsaw\" , na me : \"Poland\" , curre n cy : \"PLN\" , popula t io n : 38000000 }, { capi tal : \"Moscow\" , na me : \"Russia\" , curre n cy : \"RUB\" , popula t io n : 145000000 }, { capi tal : \"Madrid\" , na me : \"Spain\" , curre n cy : \"EUR\" , popula t io n : 47420000 }, { capi tal : \"Tunis\" , na me : \"Tunisia\" , curre n cy : \"TND\" , popula t io n : 12260000 } ]","title":"Impl\u00e9mentation du service statiquement dans Mule"},{"location":"tp2/#appel-au-service-soap-du-tp1-a-partir-de-lapi-rest","text":"L'une des grandes utilit\u00e9s d'un ESB est d'int\u00e9grer les services existants qui utilisent parfois des protocoles ou technologies diff\u00e9rentes. Nous allons montrer comment on pourra, avec notre service REST, faire appel \u00e0 un service SOAP. On rappelle que le service SOAP cr\u00e9\u00e9 pr\u00e9c\u00e9demment, prend en entr\u00e9e le nom d'un pays (param\u00e8tre name de type cha\u00eene de caract\u00e8res), et retourne une SOAP Response avec les informations relatives \u00e0 ce pays, extraites de la base de donn\u00e9es countries .","title":"Appel au service SOAP du TP1 \u00e0 partir de l'API REST"},{"location":"tp2/#modifier-le-raml-initial","text":"Nous devons modifier le fichier RAML initial de fa\u00e7on \u00e0 exposer une m\u00e9thode get qui prend en entr\u00e9e un nom de pays. Pour cela: Ouvrir le fichier RAML dans le projet countriesrestservice (vous le trouverez sous src/main/resources/api ), et ajouter, sous Member , l'\u00e9l\u00e9ment suivant: get : responses : 200 : body : application/json : type : <<item>> Pour recharger le nouveau fichier et g\u00e9n\u00e9rer le flux que nous venons de cr\u00e9er, faire un clic-droit sur le projet, et choisir Mule -> Generate Flows from Local REST API . Vous remarquerez que le flux suivant vient d'\u00eatre ajout\u00e9: Nous commencerons par tester ce service. Pour cela, dans le second Transform Message , glisser-d\u00e9placer la variable id vers la sortie name , comme suit: Relancer ce service, et observer le r\u00e9sultat en tapant le chemin http://localhost:8088/api/countries/Dorne . L'affichage est bien s\u00fbr incongru, mais \u00e7a fonctionne s'il vous donne \u00e7a: { na me : \"SpainDorne\" , popula t io n : 46704314 , capi tal : \"Madrid\" , curre n cy : \"EUR\" }","title":"Modifier le RAML initial"},{"location":"tp2/#appeler-le-service-soap","text":"Pour appeler votre service SOAP, modifier le flux de la requ\u00eate get:\\countries(id) comme suit: Supprimer tous les composants d\u00e9j\u00e0 existants. Ajouter le composant Web Service Consumer . Le configurer comme suit: Devant Connector configuration , cliquer sur pour ajouter une nouvelle configuration. Coller le chemin du WSDL de votre service SOAP dans WSDL Location (si vous n'avez rien chang\u00e9, cela devrait \u00eatre http://localhost:8081/CountriesPortService/CountriesPortSoap11?wsdl ) Cliquer sur OK pour valider. Les valeurs suivantes devraient s'afficher : Service : CountriesPortService Port : CountriesPortSoap11 Address : http://localhost:8081/CountriesPortService/CountriesPortSoap11 Une fois cette fen\u00eatre ferm\u00e9e, s\u00e9lectionner (si ce n'est d\u00e9j\u00e0 fait) getCountry dans Operation. Dans la partie Body, cliquer sur le bouton pour mapper l'entr\u00e9e du service REST \u00e0 celui du service SOAP. Glisser-d\u00e9placer ensuite la variable id se trouvant sous Attributes -> uriParams de la fen\u00eatre de gauche, vers la variable name se trouvant sous getCountryRequest de la fen\u00eatre de droite. Le code suivant devrait se g\u00e9n\u00e9rer : output application/xml ns ns0 http : //spring.io/guides/gs-producing-web-service --- { ns0#getCountryRequest : { ns0#name : attributes.uriParams.id } } Ajouter maintenant le composant Transform Message pour transformer la r\u00e9ponse SOAP re\u00e7ue en JSON. Glisser-d\u00e9placer les champs provenant du payload getCountryResponse vers l'objet en sortie. Cela devra g\u00e9n\u00e9rer le code suivant: %dw 2.0 output application/json ns ns0 http : //spring.io/guides/gs-producing-web-service --- { capital : payload.body.ns0#getCountryResponse.ns0#country.ns0#capital default \"\", name : payload.body.ns0#getCountryResponse.ns0#country.ns0#name default \"\", currency : payload.body.ns0#getCountryResponse.ns0#country.ns0#currency default \"\", population : payload.body.ns0#getCountryResponse.ns0#country.ns0#population default 0 }","title":"Appeler le service SOAP"},{"location":"tp2/#lancer-les-services","text":"Pour ex\u00e9cuter les deux services dans Anypoint, il faut suivre les \u00e9tapes suivantes: Cr\u00e9er une nouvelle configuration d'ex\u00e9cution ( Run Configurations... ) qu'on appellera services1and2 S\u00e9lectionner les deux services tp1 et countriesrestservice . Cela devra ressembler \u00e0 ce qui suit: Lancer les deux services en cliquant sur Run . Une fois les deux services lanc\u00e9s, tester la nouvelle fonctionnalit\u00e9 impl\u00e9ment\u00e9e, en allant sur le navigateur et en testant par exemple: http://localhost:8088/api/countries/Armenia . Le r\u00e9sultat affich\u00e9 sera ainsi:","title":"Lancer les services"},{"location":"tp2/#projet","text":"\u00c9tape 2 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 2 du projet, qui consiste \u00e0: Terminer les diagrammes de votre entreprise commenc\u00e9s la semaine d'avant. Concevoir et commencer l'impl\u00e9mentation des services n\u00e9cessaires pour votre PoC. R\u00e9fl\u00e9chir \u00e0 l'usage des ESB, leur r\u00f4le et les strat\u00e9gies qui y seront impl\u00e9ment\u00e9es.","title":"Projet"},{"location":"tp3/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda. Outils et Versions \u00b6 Camunda - Distribution Tomcat, Version: 7.18.0 IntelliJ IDEA Version Ultimate 2016.1 (ou tout autre IDE de votre choix) Camunda Modeler Version latest Camunda \u00b6 Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support BPMN pour l'automatisation des processus, CMMN pour le Case Management, et DMN pour le Business Decision Management. BPMN 2.0 \u00b6 BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations. Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier. Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti. Installation \u00b6 Pour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes: T\u00e9l\u00e9charger Camunda distribution Tomcat (vous la trouverez en bas de la page), IntelliJ IDEA et Camunda Modeler . D\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter start-camunda.sh (pour les syst\u00e8mes Unix-based) ou start-camunda.bat (pour les syst\u00e8mes Windows). La page d'accueil du serveur d'application va s'ouvrir dans votre navigateur pr\u00e9f\u00e9r\u00e9. Lancer le Camunda Modeler. Premier Projet Camunda BPMN: Helloworld \u00b6 Cr\u00e9ation du Projet et D\u00e9pendances \u00b6 Vous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus. Ouvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype) intitul\u00e9 HelloworldCamunda . Vous pouvez choisir les param\u00e8tres suivants: Group Id: tn.insat.urb.tp3 Artifact Id: Helloworld Version: 1 Dans le fichier pom.xml , indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier war . Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version: <packaging> war </packaging> Ajouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier pom.xml <properties> <camunda.version> 7.17.0 </camunda.version> <maven.compiler.source> 1.8 </maven.compiler.source> <maven.compiler.target> 1.8 </maven.compiler.target> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> </properties> <dependencyManagement> <dependencies> b <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-bom </artifactId> <version> ${camunda.version} </version> <scope> import </scope> <type> pom </type> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-engine </artifactId> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 4.0.1 </version> <scope> provided </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-war-plugin </artifactId> <version> 3.3.2 </version> <configuration> <failOnMissingWebXml> false </failOnMissingWebXml> </configuration> </plugin> </plugins> </build> Faire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez maven-install par exemple, et vous \u00e9crirez dans la partie Command Line : install , comme suit: Lancer le build et v\u00e9rifiez que vos packages ont bien \u00e9t\u00e9 install\u00e9s. Cr\u00e9ation de la classe principale pour le processus \u00b6 La prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda. package tn.insat.urb.tp3.helloworld ; import org.camunda.bpm.application.ProcessApplication ; import org.camunda.bpm.application.impl.ServletProcessApplication ; @ProcessApplication ( \"Helloworld App\" ) public class HelloworldApplication extends ServletProcessApplication { // empty implementation } Ajouter ensuite le fichier processes.xml sous le r\u00e9pertoire src/main/resources/META-INF . Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus. <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <process-application xmlns= \"http://www.camunda.org/schema/1.0/ProcessApplication\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" > <process-archive name= \"helloworld\" > <process-engine> default </process-engine> <properties> <property name= \"isDeleteUponUndeploy\" > false </property> <property name= \"isScanForProcessDefinitions\" > true </property> </properties> </process-archive> </process-application> A partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus. Mod\u00e9lisation d'un processus BPMN 2.0 \u00b6 La mod\u00e9lisation du processus se fera gr\u00e2ce au Camunda Modeler . Pour cela: D\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN (Camunda 7). Attention V\u00e9rifiez bien que vous avez cr\u00e9\u00e9 un diagramme Camunda Platform 7 (pas 8) Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons Dis Bonjour . Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 Ajouter Bonjour . Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel Bonjour <nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir User Task . Rajouter une t\u00e2che de fin au processus. Configuration du processus \u00b6 Pour configurer la t\u00e2che utilisateur Ajouter Bonjour , cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). Nous allons d'abord d\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ Assignee , ins\u00e9rer john . John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les. Pour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants: Id: helloworld Name: Helloworld Executable: true Nous obtenons pour finir le diagramme suivant: Sauvegarder le diagramme sous le r\u00e9pertoire src/main/resources du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez helloworld.bpmn D\u00e9ploiement du processus \u00b6 Ajouter la ligne suivante dans le fichier processes.xml : <resource> helloworld.bpmn </resource> Configurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ: Aller au menu File > Project Structure... Cliquer sur Artifacts . D\u00e9finir le type de l'archive \u00e0 d\u00e9ployer: Web Application: Archive D\u00e9finir comme Output Directory le r\u00e9pertoire webapps , se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire $CAMUNDA_HOME/server/apache-tomcat-<tomcatVersion>/webapps . Cliquer sur HelloworldCamunda-1.war. En bas de la fen\u00eatre, vous trouverez un bouton Create Manifest . Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement. Cr\u00e9ez le dans le r\u00e9pertoire resources du projet. Vous obtiendrez le r\u00e9sultat suivant: Aller au menu Build > Build Artifacts... et cliquer sur All Artifacts->Build . Normalement, un nouveau fichier HelloworldCamunda-1.war sera cr\u00e9\u00e9 dans le r\u00e9pertoire webapps du serveur. V\u00e9rification du d\u00e9ploiement avec Cockpit \u00b6 Camunda offre l'outil Cockpit pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant: http://localhost:8080/camunda/app/cockpit . Identifiez-vous comme administrateur en tapant les credentials: demo/demo . Cliquer sur le nombre sous Process Definitions (cela devra \u00eatre 3 dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat checked . D\u00e9marrage du processus \u00b6 Aller au Camunda Tasklist ( http://localhost:8080/camunda/app/tasklist ), puis lancer le processus en cliquant sur le bouton Start Process (en haut \u00e0 droite). Cliquer sur votre processus Helloworld . Ajouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable nom de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur Add a variable et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien ): En rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat Running . Configuration des permissions \u00b6 Pour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus Helloworld , il faudra lui rajouter les autorisations. Pour cela: Aller \u00e0 Camunda Admin ( http://localhost:8080/camunda/app/admin/default/#/authorization?resource=0 ). Ajouter une nouvelle autorisation dans la partie Process Definition , pour permettre \u00e0 John de manipuler la d\u00e9finition du processus Helloworld . Dans la partie Process Instance , ajouter la permission de cr\u00e9er une instance de processus \u00e0 John. Vous authentifier comme \u00e9tant John, en utilisant ( john/john ), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus. Cr\u00e9ation d'un formulaire personnalis\u00e9 \u00b6 Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service, suivre les \u00e9tapes suivantes: Revenir vers IntelliJ, et cr\u00e9er un fichier dis-bonjour.html sous le r\u00e9pertoire src/main/webapp/forms . Ajouter le contenu suivant: < form name = \"disBonjour\" > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" /> </ div > </ form > Ouvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation Forms , choisir le type Embedded or External Task Forms et ins\u00e9rer embedded:app:forms/dis-bonjour.html dans le champ Key . Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application. Sauvegarder, et rafra\u00eechir le projet dans IntelliJ. De m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera bonjour.html . < form name = \"bonjour\" > < div class = \"form-group\" > < label for = \"salutation\" > Salutation </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"salutation\" name = \"salutation\" /> </ div > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" readonly = \"true\" /> </ div > </ form > Affecter ce formulaire \u00e0 la t\u00e2che Ajouter Bonjour de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment. Sauvegarder tout et re-d\u00e9ployer le projet. Lancer maintenant le processus. Saisir votre nom dans la rubrique Nom . Identifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire: Pour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un Service Task . Ajout d'un Service Task Java \u00b6 Pour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes: Utiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette , s\u00e9lectionner l'option Service Task . Appeler le service Dire Bonjour . Vous obtiendrez le r\u00e9sultat suivant: Ajouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e ProcessRequestDelegate qui impl\u00e9mente l'interface JavaDelegate , comme suit: package tn.insat.urb.tp3.helloworld ; import java.util.logging.Logger ; import org.camunda.bpm.engine.delegate.DelegateExecution ; import org.camunda.bpm.engine.delegate.JavaDelegate ; public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"!\" ); } } Dans le Modeler, utiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class: tn.insat.urb.tp3.helloworld.ProcessRequestDelegate . D\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit: Appel d'un Service Web REST \u00b6 Gr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour. Commencer par ajuster le formulaire bonjour.html , en lui ajoutant un autre champs de texte: ville apr\u00e8s le champs nom . Revenir dans le Modeler, et ajouter un Service Task, qu'on appellera Consulter M\u00e9t\u00e9o , entre Ajouter Bonjour et Dire Bonjour . Dans ce service, indiquer que le type d'impl\u00e9mentation est Connector . Donner les param\u00e8tres suivants \u00e0 votre connecteur; Id : http-connector Connector Input : Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web OpenWeatherMap . Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs ville . Nom Type Valeur url Script / JavaScript / Inline Script var ville=execution.getVariable(\"ville\"); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266&q='+ville; method String or Expression GET headers Map key: accept, value:application/json - key:content-type, value:application/json Connector Output : Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit: { coord : { lon : 10.17 , lat : 36.82 }, weather : [ { id : 801 , main : \"Clouds\" , description : \"few clouds\" , icon : \"02d\" } ], base : \"stations\" , main : { temp : 299.87 , pressure : 1018 , humidity : 39 , temp_min : 299.15 , temp_max : 301.15 }, visibility : 10000 , wind : { speed : 3.6 , deg : 40 }, clouds : { all : 20 }, dt : 1506864600 , sys : { type : 1 , id : 6318 , message : 0.0039 , country : \"TN\" , sunrise : 1506834907 , sunset : 1506877308 }, id : 2464470 , name : \"Tunis\" , cod : 200 } Si l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment main puis \u00e0 son fils temp . L'output de notre service aura donc la forme suivante: Nom Type Valeur WsResponse Script / JavaScript / Inline Script S(response).prop(\"main\").prop(\"temp\").numberValue(); Tip Toujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application! Maintenant, ajouter le code d'exploitation de ce service dans la classe ProcessRequestDelegate , pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate: public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"! La temp\u00e9rature aujourd'hui \u00e0 \" + execution . getVariable ( \"ville\" ) + \" est de \" + execution . getVariable ( \"WsResponse\" ) + \"!\" ); } } Tout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant: L'utilisateur demo saisit son nom: L'utilisateur john rajoute la salutation et la ville: Le processus affiche ce r\u00e9sultat sur le log: Homework \u00b6 Projet E3 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 3 du projet, qui consiste \u00e0: Concevoir et impl\u00e9menter les processus m\u00e9tiers choisis de votre entreprise, avec Camunda ou tout autre outil BPM de votre choix. Commencer l'impl\u00e9mentation et configuration de votre ESB, pour permettre la communication entre les services, processus m\u00e9tiers et clients.","title":"TP3 - Orchestration de Services avec Camunda"},{"location":"tp3/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp3/#objectifs-du-tp","text":"Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda.","title":"Objectifs du TP"},{"location":"tp3/#outils-et-versions","text":"Camunda - Distribution Tomcat, Version: 7.18.0 IntelliJ IDEA Version Ultimate 2016.1 (ou tout autre IDE de votre choix) Camunda Modeler Version latest","title":"Outils et Versions"},{"location":"tp3/#camunda","text":"Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support BPMN pour l'automatisation des processus, CMMN pour le Case Management, et DMN pour le Business Decision Management.","title":"Camunda"},{"location":"tp3/#bpmn-20","text":"BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations. Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier. Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti.","title":"BPMN 2.0"},{"location":"tp3/#installation","text":"Pour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes: T\u00e9l\u00e9charger Camunda distribution Tomcat (vous la trouverez en bas de la page), IntelliJ IDEA et Camunda Modeler . D\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter start-camunda.sh (pour les syst\u00e8mes Unix-based) ou start-camunda.bat (pour les syst\u00e8mes Windows). La page d'accueil du serveur d'application va s'ouvrir dans votre navigateur pr\u00e9f\u00e9r\u00e9. Lancer le Camunda Modeler.","title":"Installation"},{"location":"tp3/#premier-projet-camunda-bpmn-helloworld","text":"","title":"Premier Projet Camunda BPMN: Helloworld"},{"location":"tp3/#creation-du-projet-et-dependances","text":"Vous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus. Ouvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype) intitul\u00e9 HelloworldCamunda . Vous pouvez choisir les param\u00e8tres suivants: Group Id: tn.insat.urb.tp3 Artifact Id: Helloworld Version: 1 Dans le fichier pom.xml , indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier war . Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version: <packaging> war </packaging> Ajouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier pom.xml <properties> <camunda.version> 7.17.0 </camunda.version> <maven.compiler.source> 1.8 </maven.compiler.source> <maven.compiler.target> 1.8 </maven.compiler.target> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> </properties> <dependencyManagement> <dependencies> b <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-bom </artifactId> <version> ${camunda.version} </version> <scope> import </scope> <type> pom </type> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-engine </artifactId> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 4.0.1 </version> <scope> provided </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-war-plugin </artifactId> <version> 3.3.2 </version> <configuration> <failOnMissingWebXml> false </failOnMissingWebXml> </configuration> </plugin> </plugins> </build> Faire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez maven-install par exemple, et vous \u00e9crirez dans la partie Command Line : install , comme suit: Lancer le build et v\u00e9rifiez que vos packages ont bien \u00e9t\u00e9 install\u00e9s.","title":"Cr\u00e9ation du Projet et D\u00e9pendances"},{"location":"tp3/#creation-de-la-classe-principale-pour-le-processus","text":"La prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda. package tn.insat.urb.tp3.helloworld ; import org.camunda.bpm.application.ProcessApplication ; import org.camunda.bpm.application.impl.ServletProcessApplication ; @ProcessApplication ( \"Helloworld App\" ) public class HelloworldApplication extends ServletProcessApplication { // empty implementation } Ajouter ensuite le fichier processes.xml sous le r\u00e9pertoire src/main/resources/META-INF . Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus. <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <process-application xmlns= \"http://www.camunda.org/schema/1.0/ProcessApplication\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" > <process-archive name= \"helloworld\" > <process-engine> default </process-engine> <properties> <property name= \"isDeleteUponUndeploy\" > false </property> <property name= \"isScanForProcessDefinitions\" > true </property> </properties> </process-archive> </process-application> A partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus.","title":"Cr\u00e9ation de la classe principale pour le processus"},{"location":"tp3/#modelisation-dun-processus-bpmn-20","text":"La mod\u00e9lisation du processus se fera gr\u00e2ce au Camunda Modeler . Pour cela: D\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN (Camunda 7). Attention V\u00e9rifiez bien que vous avez cr\u00e9\u00e9 un diagramme Camunda Platform 7 (pas 8) Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons Dis Bonjour . Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 Ajouter Bonjour . Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel Bonjour <nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir User Task . Rajouter une t\u00e2che de fin au processus.","title":"Mod\u00e9lisation d'un processus BPMN 2.0"},{"location":"tp3/#configuration-du-processus","text":"Pour configurer la t\u00e2che utilisateur Ajouter Bonjour , cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). Nous allons d'abord d\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ Assignee , ins\u00e9rer john . John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les. Pour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants: Id: helloworld Name: Helloworld Executable: true Nous obtenons pour finir le diagramme suivant: Sauvegarder le diagramme sous le r\u00e9pertoire src/main/resources du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez helloworld.bpmn","title":"Configuration du processus"},{"location":"tp3/#deploiement-du-processus","text":"Ajouter la ligne suivante dans le fichier processes.xml : <resource> helloworld.bpmn </resource> Configurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ: Aller au menu File > Project Structure... Cliquer sur Artifacts . D\u00e9finir le type de l'archive \u00e0 d\u00e9ployer: Web Application: Archive D\u00e9finir comme Output Directory le r\u00e9pertoire webapps , se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire $CAMUNDA_HOME/server/apache-tomcat-<tomcatVersion>/webapps . Cliquer sur HelloworldCamunda-1.war. En bas de la fen\u00eatre, vous trouverez un bouton Create Manifest . Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement. Cr\u00e9ez le dans le r\u00e9pertoire resources du projet. Vous obtiendrez le r\u00e9sultat suivant: Aller au menu Build > Build Artifacts... et cliquer sur All Artifacts->Build . Normalement, un nouveau fichier HelloworldCamunda-1.war sera cr\u00e9\u00e9 dans le r\u00e9pertoire webapps du serveur.","title":"D\u00e9ploiement du processus"},{"location":"tp3/#verification-du-deploiement-avec-cockpit","text":"Camunda offre l'outil Cockpit pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant: http://localhost:8080/camunda/app/cockpit . Identifiez-vous comme administrateur en tapant les credentials: demo/demo . Cliquer sur le nombre sous Process Definitions (cela devra \u00eatre 3 dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat checked .","title":"V\u00e9rification du d\u00e9ploiement avec Cockpit"},{"location":"tp3/#demarrage-du-processus","text":"Aller au Camunda Tasklist ( http://localhost:8080/camunda/app/tasklist ), puis lancer le processus en cliquant sur le bouton Start Process (en haut \u00e0 droite). Cliquer sur votre processus Helloworld . Ajouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable nom de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur Add a variable et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien ): En rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat Running .","title":"D\u00e9marrage du processus"},{"location":"tp3/#configuration-des-permissions","text":"Pour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus Helloworld , il faudra lui rajouter les autorisations. Pour cela: Aller \u00e0 Camunda Admin ( http://localhost:8080/camunda/app/admin/default/#/authorization?resource=0 ). Ajouter une nouvelle autorisation dans la partie Process Definition , pour permettre \u00e0 John de manipuler la d\u00e9finition du processus Helloworld . Dans la partie Process Instance , ajouter la permission de cr\u00e9er une instance de processus \u00e0 John. Vous authentifier comme \u00e9tant John, en utilisant ( john/john ), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus.","title":"Configuration des permissions"},{"location":"tp3/#creation-dun-formulaire-personnalise","text":"Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service, suivre les \u00e9tapes suivantes: Revenir vers IntelliJ, et cr\u00e9er un fichier dis-bonjour.html sous le r\u00e9pertoire src/main/webapp/forms . Ajouter le contenu suivant: < form name = \"disBonjour\" > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" /> </ div > </ form > Ouvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation Forms , choisir le type Embedded or External Task Forms et ins\u00e9rer embedded:app:forms/dis-bonjour.html dans le champ Key . Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application. Sauvegarder, et rafra\u00eechir le projet dans IntelliJ. De m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera bonjour.html . < form name = \"bonjour\" > < div class = \"form-group\" > < label for = \"salutation\" > Salutation </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"salutation\" name = \"salutation\" /> </ div > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" readonly = \"true\" /> </ div > </ form > Affecter ce formulaire \u00e0 la t\u00e2che Ajouter Bonjour de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment. Sauvegarder tout et re-d\u00e9ployer le projet. Lancer maintenant le processus. Saisir votre nom dans la rubrique Nom . Identifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire: Pour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un Service Task .","title":"Cr\u00e9ation d'un formulaire personnalis\u00e9"},{"location":"tp3/#ajout-dun-service-task-java","text":"Pour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes: Utiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette , s\u00e9lectionner l'option Service Task . Appeler le service Dire Bonjour . Vous obtiendrez le r\u00e9sultat suivant: Ajouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e ProcessRequestDelegate qui impl\u00e9mente l'interface JavaDelegate , comme suit: package tn.insat.urb.tp3.helloworld ; import java.util.logging.Logger ; import org.camunda.bpm.engine.delegate.DelegateExecution ; import org.camunda.bpm.engine.delegate.JavaDelegate ; public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"!\" ); } } Dans le Modeler, utiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class: tn.insat.urb.tp3.helloworld.ProcessRequestDelegate . D\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit:","title":"Ajout d'un Service Task Java"},{"location":"tp3/#appel-dun-service-web-rest","text":"Gr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour. Commencer par ajuster le formulaire bonjour.html , en lui ajoutant un autre champs de texte: ville apr\u00e8s le champs nom . Revenir dans le Modeler, et ajouter un Service Task, qu'on appellera Consulter M\u00e9t\u00e9o , entre Ajouter Bonjour et Dire Bonjour . Dans ce service, indiquer que le type d'impl\u00e9mentation est Connector . Donner les param\u00e8tres suivants \u00e0 votre connecteur; Id : http-connector Connector Input : Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web OpenWeatherMap . Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs ville . Nom Type Valeur url Script / JavaScript / Inline Script var ville=execution.getVariable(\"ville\"); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266&q='+ville; method String or Expression GET headers Map key: accept, value:application/json - key:content-type, value:application/json Connector Output : Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit: { coord : { lon : 10.17 , lat : 36.82 }, weather : [ { id : 801 , main : \"Clouds\" , description : \"few clouds\" , icon : \"02d\" } ], base : \"stations\" , main : { temp : 299.87 , pressure : 1018 , humidity : 39 , temp_min : 299.15 , temp_max : 301.15 }, visibility : 10000 , wind : { speed : 3.6 , deg : 40 }, clouds : { all : 20 }, dt : 1506864600 , sys : { type : 1 , id : 6318 , message : 0.0039 , country : \"TN\" , sunrise : 1506834907 , sunset : 1506877308 }, id : 2464470 , name : \"Tunis\" , cod : 200 } Si l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment main puis \u00e0 son fils temp . L'output de notre service aura donc la forme suivante: Nom Type Valeur WsResponse Script / JavaScript / Inline Script S(response).prop(\"main\").prop(\"temp\").numberValue(); Tip Toujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application! Maintenant, ajouter le code d'exploitation de ce service dans la classe ProcessRequestDelegate , pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate: public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"! La temp\u00e9rature aujourd'hui \u00e0 \" + execution . getVariable ( \"ville\" ) + \" est de \" + execution . getVariable ( \"WsResponse\" ) + \"!\" ); } } Tout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant: L'utilisateur demo saisit son nom: L'utilisateur john rajoute la salutation et la ville: Le processus affiche ce r\u00e9sultat sur le log:","title":"Appel d'un Service Web REST"},{"location":"tp3/#homework","text":"Projet E3 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 3 du projet, qui consiste \u00e0: Concevoir et impl\u00e9menter les processus m\u00e9tiers choisis de votre entreprise, avec Camunda ou tout autre outil BPM de votre choix. Commencer l'impl\u00e9mentation et configuration de votre ESB, pour permettre la communication entre les services, processus m\u00e9tiers et clients.","title":"Homework"},{"location":"tp3_deprecated/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda. Outils et Versions \u00b6 Pour ce TP, nous allons utiliser la version SaaS de Camunda et Camunda Modeler : Camunda - Version latest VsCode - Version latest (ou tout autre IDE de votre choix) Java - Version 17 ou plus. Camunda \u00b6 Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support BPMN pour l'automatisation des processus, CMMN pour le Case Management, et DMN pour le Business Decision Management. BPMN 2.0 \u00b6 BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations. Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier. Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti. Mise en marche \u00b6 Pour les besoins de ce TP, cr\u00e9er d'abord un compte sur Camunda . Une fois c'est fait, suivre les \u00e9tapes pour cr\u00e9er un cluster temporaire. Vous vous retrouverez dans la fen\u00eatre Console, qui ressemble \u00e0 ce qui suit: Premier Projet Camunda BPMN \u00b6 Mod\u00e9lisation du processus Helloworld \u00b6 Nous allons utiliser le Web Modeler pour concevoir un diagramme BPMN. Pour cela: Cliquer sur le bouton carr\u00e9 se trouvant en haut \u00e0 gauche de la fen\u00eatre ( ). Choisir ensuite Modeler puis cliquer sur New Project . Appeler le projet Helloworld , ensuite cliquer sur Create New File -> BPMN Diagram . Appeler le diagramme HelloworldDiagram , puis aller dans, propri\u00e9t\u00e9s du diagramme, sous l'onglet General , d\u00e9finir: Name : Helloworld ID : ProcessHW Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons Dis Bonjour . Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 Ajouter Bonjour . Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel Bonjour <nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir User Task . On l'appellera Bonjour qui? Rajouter une t\u00e2che de fin au processus. Nous obtenons pour finir le diagramme suivant: Premier d\u00e9ploiement et test \u00b6 Pour d\u00e9ployer votre processus, il suffit de cliquer sur Deploy . Le processus Helloworld sera d\u00e9ploy\u00e9 sur le cluster nouvellement cr\u00e9\u00e9. Pour ex\u00e9cuter le processus: Cliquer sur Run . Pour voir l'\u00e9tat du processus en cours: Cliquer sur le bouton ( ), puis sur Operate . Cliquer sur l'instance active Helloworld. Dans Operate, vous verrez une visualisation de l'instance du processus en cours. Remarquez qu'un jeton vert est en attente \u00e0 la t\u00e2che de l'utilisateur. Cela signifie qu'une t\u00e2che attend d'\u00eatre trait\u00e9e dans la liste des t\u00e2ches. Pour ex\u00e9cuter le processus: Cliquer encore une fois sur ( ), puis sur Tasklist . Cliquer ensuite sur Bonjour qui? . La t\u00e2che n'\u00e9tant actuellement affect\u00e9e \u00e0 aucun utilisateur, vous verrez Unassigned \u00e0 c\u00f4t\u00e9 du bon de la t\u00e2che. Cliquer sur Assign to me . Cliquer ensuite sur Complete Task . Nous n'avions de toute fa\u00e7on rien d'autre \u00e0 faire. La t\u00e2che passera \u00e0 l'\u00e9tat Completed , et on verra dans la fen\u00eatre Operate que le marqueur vert a disparu. Cr\u00e9ation d'un formulaire personnalis\u00e9 \u00b6 Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service, suivre les \u00e9tapes suivantes: Revenir vers le Modeler, et cliquer sur la t\u00e2che utilisateur Bonjour qui? . Cliquer sur le bouton bleu qui appara\u00eet, puis sur Create new form , comme indiqu\u00e9 dans la fen\u00eatre suivante: Ajouter dans le g\u00e9n\u00e9rateur de formulaire un champs de type Text Area . Changer son label pour Nom et sa clef pour nom . Cette clef repr\u00e9sentera une variable de processus, veiller \u00e0 ce qu'elle soit unique. Une fois le fomulaire cr\u00e9\u00e9, il faut l'assosier \u00e0 la t\u00e2che. Revenir vers le diagramme en cliquant sur Helloworld dans l'historique de navigation en haut de la fen\u00eatre, puis en revenant vers le Helloworld Diagram . Refaire les m\u00eames \u00e9tapes en cliquant sur la t\u00e2che Bonjour qui? , sur le bouton de formulaire, mais en choisissant maintenant le nouveau formulaire cr\u00e9\u00e9 qui s'appelle aussi Bonjour qui? . Testons maintenant que ce formulaire marche bien. Pour cela, red\u00e9ployer le processus puis l'ex\u00e9cuter. Vous verrez cette fois la variable nom dans la liste des variables. Une fois le processus affect\u00e9 \u00e0 vous, d\u00e9finir la valeur de nom, puis cliquer sur Complete Task . Rien ne se passera, car on n'a pas dit ce qu'on devait faire avec cette nouvelle entr\u00e9e. Nous allons le faire dans la partie suivante. Cr\u00e9ation d'un Service Task avec un connecteur Java \u00b6 La fameuse salutation Hello ! sera r\u00e9alis\u00e9e par une nouvelle t\u00e2che de type Service Task . Pour la d\u00e9finir: Ins\u00e9rer une t\u00e2che Bonjour! de type Service Task entre Bonjour qui? et la t\u00e2che de fin. Pour la configurer, il faut: Lui donner un type: c'est une cha\u00eene de caract\u00e8res permettant d'identifier la t\u00e2che de faon unique, et de lui associer le traitement \u00e0 faire, plus tard dans le code. Nous allons d\u00e9finir comme type: hello . Ajouter dans la partie Headers l'\u00e9l\u00e9ment suivant, qui indique que la sortie de cette t\u00e2che sera contenue dans une variable greeting : Key: resultVariable Value: greeting Nous allons maintenant cr\u00e9er un connecteur de type Spring app, dont le but est de d\u00e9finir le comportement de la t\u00e2che. Cela va de soi que ce que nous pr\u00e9sentons ici est une version simplifi\u00e9e de ce qui pourra \u00eatre plus tard, un comportement bien plus complexe du processus. Nous allons pour r\u00e9aliser ce service adapter un code fourni par Camunda. Je me suis inspir\u00e9e dans cette partie de leur tutoriel vid\u00e9o . Cloner le projet Git suivant: https://github.com/camunda/connector-template-outbound/ Ce projet d\u00e9finit principalement 5 fichiers importants: La classe MyConnectorRequest : repr\u00e9sente le format de l'input de la Service Task qu'on essaie d'impl\u00e9menter. Dans le projet initial, cet input d\u00e9finit deux variables: message (de type texte) et authentication (de type map, contenant deux \u00e9lements: un user et un token). Il faut modifier cette requ\u00eate pour qu'elle accepte uniquement une entr\u00e9e de type texte, appel\u00e9e nom . La classe MyConnectorResult , qui d\u00e9finit le format de la sortie de la t\u00e2che. Cette sortie est une cha\u00eene de caract\u00e8res myProperty , nous allons la garder telle qu'elle est. La classe MyConnectorFunction , qui d\u00e9crit: Le connecteur dans l'annotation @OutboundConnector . Nous devons le modifier de fa\u00e7on \u00e0 ce qu'il accepte comme entr\u00e9e un seul \u00e9lement nom , et que le type soit \"hello\" : c'est le m\u00eame type que nous avons associ\u00e9 \u00e0 la t\u00e2che dans le modeler. La m\u00e9thode executeConnector qui d\u00e9finit le comportement du connecteur. Nous aimerions juste qu'il sauvegarde l'input nom trouv\u00e9 dans la requ\u00eate dans une variable, puis qu'il donne en sortie: \"Bonjour <nom>!\" La classe LocalConnectorRuntime sous le r\u00e9pertoire test : Cette classe permet de lancer la t\u00e2che. Il est recommand\u00e9 de supprimer les autres classes de test pour \u00e9viter les erreurs. Elles nous sont inutiles pour le moment. Le fichier application.properties sous le r\u00e9pertoire test Ce fichier contient les informations de connexion au cluster Camunda. Il faut supprimer le contenu de ce fichier, et garder uniquement la ligne camunda.connector.polling.enabled=false . Nous allons le remplir avec les informations n\u00e9cessaires plus tard. Une fois les modifications apport\u00e9es au code, nous allons ajouter les informations de connexion au cluster. Pour cela: Dans Camunda Console, dans les informations de votre cluster, cliquer sur l'onglet API . Cr\u00e9er une nouvelle API. Lui donner un nom de votre choix, et garder les autres config telles qu'elles. Copier et t\u00e9l\u00e9charger les informations donn\u00e9es sous l'onglet Spring Boot . Coller ces donn\u00e9es dans le fichier application.properties . Ex\u00e9cuter votre connecteur en lan\u00e7ant la classe LocalConnectorRuntime . V\u00e9rifier bien que la sortie ressemble \u00e0 ce qui suit: Nous allons maintenant le tester. Lancer le processus et observer son avancement dans la page Operate. Le processus commence par attendre l'input de l'utilisateur dans la t\u00e2che Bonjour qui? : Ouvrir la fen\u00eatre Tasklist et lancer le processus. Saisir votre nom dans le champ Nom : Revenir \u00e0 la fen\u00eatre Operate . Si tout se passe bien, le processus aura \u00e9t\u00e9 achev\u00e9, et une nouvelle variable appara\u00eet: greeting , avec la valeur : Bonjour <votre_nom>! Projet \u00b6 \u00c9tape 3 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 3 du projet, qui consiste \u00e0: Concevoir et impl\u00e9menter les processus m\u00e9tiers choisis de votre entreprise, avec Camunda ou tout autre outil BPM de votre choix. Commencer l'impl\u00e9mentation et configuration de votre ESB, pour permettre la communication entre les services, processus m\u00e9tiers et clients.","title":"Tp3 deprecated"},{"location":"tp3_deprecated/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp3_deprecated/#objectifs-du-tp","text":"Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda.","title":"Objectifs du TP"},{"location":"tp3_deprecated/#outils-et-versions","text":"Pour ce TP, nous allons utiliser la version SaaS de Camunda et Camunda Modeler : Camunda - Version latest VsCode - Version latest (ou tout autre IDE de votre choix) Java - Version 17 ou plus.","title":"Outils et Versions"},{"location":"tp3_deprecated/#camunda","text":"Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support BPMN pour l'automatisation des processus, CMMN pour le Case Management, et DMN pour le Business Decision Management.","title":"Camunda"},{"location":"tp3_deprecated/#bpmn-20","text":"BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations. Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier. Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti.","title":"BPMN 2.0"},{"location":"tp3_deprecated/#mise-en-marche","text":"Pour les besoins de ce TP, cr\u00e9er d'abord un compte sur Camunda . Une fois c'est fait, suivre les \u00e9tapes pour cr\u00e9er un cluster temporaire. Vous vous retrouverez dans la fen\u00eatre Console, qui ressemble \u00e0 ce qui suit:","title":"Mise en marche"},{"location":"tp3_deprecated/#premier-projet-camunda-bpmn","text":"","title":"Premier Projet Camunda BPMN"},{"location":"tp3_deprecated/#modelisation-du-processus-helloworld","text":"Nous allons utiliser le Web Modeler pour concevoir un diagramme BPMN. Pour cela: Cliquer sur le bouton carr\u00e9 se trouvant en haut \u00e0 gauche de la fen\u00eatre ( ). Choisir ensuite Modeler puis cliquer sur New Project . Appeler le projet Helloworld , ensuite cliquer sur Create New File -> BPMN Diagram . Appeler le diagramme HelloworldDiagram , puis aller dans, propri\u00e9t\u00e9s du diagramme, sous l'onglet General , d\u00e9finir: Name : Helloworld ID : ProcessHW Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons Dis Bonjour . Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 Ajouter Bonjour . Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel Bonjour <nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir User Task . On l'appellera Bonjour qui? Rajouter une t\u00e2che de fin au processus. Nous obtenons pour finir le diagramme suivant:","title":"Mod\u00e9lisation du processus Helloworld"},{"location":"tp3_deprecated/#premier-deploiement-et-test","text":"Pour d\u00e9ployer votre processus, il suffit de cliquer sur Deploy . Le processus Helloworld sera d\u00e9ploy\u00e9 sur le cluster nouvellement cr\u00e9\u00e9. Pour ex\u00e9cuter le processus: Cliquer sur Run . Pour voir l'\u00e9tat du processus en cours: Cliquer sur le bouton ( ), puis sur Operate . Cliquer sur l'instance active Helloworld. Dans Operate, vous verrez une visualisation de l'instance du processus en cours. Remarquez qu'un jeton vert est en attente \u00e0 la t\u00e2che de l'utilisateur. Cela signifie qu'une t\u00e2che attend d'\u00eatre trait\u00e9e dans la liste des t\u00e2ches. Pour ex\u00e9cuter le processus: Cliquer encore une fois sur ( ), puis sur Tasklist . Cliquer ensuite sur Bonjour qui? . La t\u00e2che n'\u00e9tant actuellement affect\u00e9e \u00e0 aucun utilisateur, vous verrez Unassigned \u00e0 c\u00f4t\u00e9 du bon de la t\u00e2che. Cliquer sur Assign to me . Cliquer ensuite sur Complete Task . Nous n'avions de toute fa\u00e7on rien d'autre \u00e0 faire. La t\u00e2che passera \u00e0 l'\u00e9tat Completed , et on verra dans la fen\u00eatre Operate que le marqueur vert a disparu.","title":"Premier d\u00e9ploiement et test"},{"location":"tp3_deprecated/#creation-dun-formulaire-personnalise","text":"Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service, suivre les \u00e9tapes suivantes: Revenir vers le Modeler, et cliquer sur la t\u00e2che utilisateur Bonjour qui? . Cliquer sur le bouton bleu qui appara\u00eet, puis sur Create new form , comme indiqu\u00e9 dans la fen\u00eatre suivante: Ajouter dans le g\u00e9n\u00e9rateur de formulaire un champs de type Text Area . Changer son label pour Nom et sa clef pour nom . Cette clef repr\u00e9sentera une variable de processus, veiller \u00e0 ce qu'elle soit unique. Une fois le fomulaire cr\u00e9\u00e9, il faut l'assosier \u00e0 la t\u00e2che. Revenir vers le diagramme en cliquant sur Helloworld dans l'historique de navigation en haut de la fen\u00eatre, puis en revenant vers le Helloworld Diagram . Refaire les m\u00eames \u00e9tapes en cliquant sur la t\u00e2che Bonjour qui? , sur le bouton de formulaire, mais en choisissant maintenant le nouveau formulaire cr\u00e9\u00e9 qui s'appelle aussi Bonjour qui? . Testons maintenant que ce formulaire marche bien. Pour cela, red\u00e9ployer le processus puis l'ex\u00e9cuter. Vous verrez cette fois la variable nom dans la liste des variables. Une fois le processus affect\u00e9 \u00e0 vous, d\u00e9finir la valeur de nom, puis cliquer sur Complete Task . Rien ne se passera, car on n'a pas dit ce qu'on devait faire avec cette nouvelle entr\u00e9e. Nous allons le faire dans la partie suivante.","title":"Cr\u00e9ation d'un formulaire personnalis\u00e9"},{"location":"tp3_deprecated/#creation-dun-service-task-avec-un-connecteur-java","text":"La fameuse salutation Hello ! sera r\u00e9alis\u00e9e par une nouvelle t\u00e2che de type Service Task . Pour la d\u00e9finir: Ins\u00e9rer une t\u00e2che Bonjour! de type Service Task entre Bonjour qui? et la t\u00e2che de fin. Pour la configurer, il faut: Lui donner un type: c'est une cha\u00eene de caract\u00e8res permettant d'identifier la t\u00e2che de faon unique, et de lui associer le traitement \u00e0 faire, plus tard dans le code. Nous allons d\u00e9finir comme type: hello . Ajouter dans la partie Headers l'\u00e9l\u00e9ment suivant, qui indique que la sortie de cette t\u00e2che sera contenue dans une variable greeting : Key: resultVariable Value: greeting Nous allons maintenant cr\u00e9er un connecteur de type Spring app, dont le but est de d\u00e9finir le comportement de la t\u00e2che. Cela va de soi que ce que nous pr\u00e9sentons ici est une version simplifi\u00e9e de ce qui pourra \u00eatre plus tard, un comportement bien plus complexe du processus. Nous allons pour r\u00e9aliser ce service adapter un code fourni par Camunda. Je me suis inspir\u00e9e dans cette partie de leur tutoriel vid\u00e9o . Cloner le projet Git suivant: https://github.com/camunda/connector-template-outbound/ Ce projet d\u00e9finit principalement 5 fichiers importants: La classe MyConnectorRequest : repr\u00e9sente le format de l'input de la Service Task qu'on essaie d'impl\u00e9menter. Dans le projet initial, cet input d\u00e9finit deux variables: message (de type texte) et authentication (de type map, contenant deux \u00e9lements: un user et un token). Il faut modifier cette requ\u00eate pour qu'elle accepte uniquement une entr\u00e9e de type texte, appel\u00e9e nom . La classe MyConnectorResult , qui d\u00e9finit le format de la sortie de la t\u00e2che. Cette sortie est une cha\u00eene de caract\u00e8res myProperty , nous allons la garder telle qu'elle est. La classe MyConnectorFunction , qui d\u00e9crit: Le connecteur dans l'annotation @OutboundConnector . Nous devons le modifier de fa\u00e7on \u00e0 ce qu'il accepte comme entr\u00e9e un seul \u00e9lement nom , et que le type soit \"hello\" : c'est le m\u00eame type que nous avons associ\u00e9 \u00e0 la t\u00e2che dans le modeler. La m\u00e9thode executeConnector qui d\u00e9finit le comportement du connecteur. Nous aimerions juste qu'il sauvegarde l'input nom trouv\u00e9 dans la requ\u00eate dans une variable, puis qu'il donne en sortie: \"Bonjour <nom>!\" La classe LocalConnectorRuntime sous le r\u00e9pertoire test : Cette classe permet de lancer la t\u00e2che. Il est recommand\u00e9 de supprimer les autres classes de test pour \u00e9viter les erreurs. Elles nous sont inutiles pour le moment. Le fichier application.properties sous le r\u00e9pertoire test Ce fichier contient les informations de connexion au cluster Camunda. Il faut supprimer le contenu de ce fichier, et garder uniquement la ligne camunda.connector.polling.enabled=false . Nous allons le remplir avec les informations n\u00e9cessaires plus tard. Une fois les modifications apport\u00e9es au code, nous allons ajouter les informations de connexion au cluster. Pour cela: Dans Camunda Console, dans les informations de votre cluster, cliquer sur l'onglet API . Cr\u00e9er une nouvelle API. Lui donner un nom de votre choix, et garder les autres config telles qu'elles. Copier et t\u00e9l\u00e9charger les informations donn\u00e9es sous l'onglet Spring Boot . Coller ces donn\u00e9es dans le fichier application.properties . Ex\u00e9cuter votre connecteur en lan\u00e7ant la classe LocalConnectorRuntime . V\u00e9rifier bien que la sortie ressemble \u00e0 ce qui suit: Nous allons maintenant le tester. Lancer le processus et observer son avancement dans la page Operate. Le processus commence par attendre l'input de l'utilisateur dans la t\u00e2che Bonjour qui? : Ouvrir la fen\u00eatre Tasklist et lancer le processus. Saisir votre nom dans le champ Nom : Revenir \u00e0 la fen\u00eatre Operate . Si tout se passe bien, le processus aura \u00e9t\u00e9 achev\u00e9, et une nouvelle variable appara\u00eet: greeting , avec la valeur : Bonjour <votre_nom>!","title":"Cr\u00e9ation d'un Service Task avec un connecteur Java"},{"location":"tp3_deprecated/#projet","text":"\u00c9tape 3 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 3 du projet, qui consiste \u00e0: Concevoir et impl\u00e9menter les processus m\u00e9tiers choisis de votre entreprise, avec Camunda ou tout autre outil BPM de votre choix. Commencer l'impl\u00e9mentation et configuration de votre ESB, pour permettre la communication entre les services, processus m\u00e9tiers et clients.","title":"Projet"},{"location":"tp4-old/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 G\u00e9n\u00e9ration d\u2019API avec Anypoint API Designer et le langage RAML Gestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft Outils et Versions \u00b6 Anypoint Studio 7 and Mule ESB 4 MySQL Version latest !!!!!!!! Dans ce TP, nous aurons besoin du service cr\u00e9\u00e9 dans le TP1 , ou bien de n'importe quel service REST de votre choix API Management avec Anypoint Studio \u00b6 G\u00e9n\u00e9ration d'API avec RAML \u00b6 RAML \u00b6 RAML (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful. RAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles technologies, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage. G\u00e9n\u00e9ration de l'API RAML avec AnyPoint API Designer \u00b6 Pour \u00e9crire un document RAML de mani\u00e8re simple et intuitive, ouvrir Anypoint Studio, et cr\u00e9er un nouveau projet de type \"API Specification Project\" , intitul\u00e9 Pet Shop de type RAML 1.0 . L'interface suivante devra s'afficher: Cr\u00e9ation d\u2019un document RAML \u00b6 Dans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations d\u00e9crites dans le cours. Cr\u00e9ation d\u2019une API RAML \u00b6 Remplir le fichier pet-shop.raml cr\u00e9\u00e9 pour qu'il ressemble \u00e0 ce qui suit: #RAML 1.0 title : Pet Shop version : v1 baseUri : /pets /pets : get : responses : 200 : body : application/json : properties : name : string kind : string price : number post : body : application/json : properties : name : string kind : string price : number /{id} : delete : responses : 204 : put : body : application/json : properties : name : string kind : string price : number Dans cette description, nous d\u00e9finissons le comportement principal de l'API, \u00e0 l'appel des quatre m\u00e9thodes les plus fr\u00e9quentes: un GET ou un POST sur la ressource principale, et un DELETE ou un PUT sur un objet particulier repr\u00e9sent\u00e9 par son id . D\u00e9finir des types \u00b6 Pour \u00e9viter les redondances constat\u00e9es dans notre d\u00e9finition, nous cr\u00e9ons le type Pet . Pour cela: Dans une nouvelle ligne au dessus de /pets , taper les lignes suivantes: types : Pet : properties : name : string kind : string price : number D\u00e9finir Pet comme type pour le corps de la m\u00e9thode post , en \u00e9crivant: type: Pet au dessous de application/json de la m\u00e9thode post Ajouter de m\u00eame Pet comme type pour la m\u00e9thode put, et Pet[] pour la m\u00e9thode get. Extraction d\u2019un type de ressources \u00b6 Pour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante: Ajouter le code suivant au dessus du title : resourceTypes : Collection : get : responses : 200 : body : application/json : type : Pet[] post : body : application/json : type : Pet Member : delete : responses : 204 : put : body : application/json : type : Pet Supprimer le contenu de /pets et de /{id} pour le remplacer par les nouveaux resourceTypes d\u00e9finis en utilisant: type: Collection et type: Member . Ajout de param\u00e8tres au type de ressource \u00b6 Pour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela: Remplacer le terme Pet dans Collection et Member par <<item>> . Remplacer les ressources Collection et Member respectivement par { Collection: {item : Pet} } et { Member: {item : Pet} } Ajout d\u2019un exemple \u00b6 Pour ajouter un exemple d\u2019animal, modifier le type Pet pour qu\u2019il soit comme suit: types : Pet : properties : name : string kind : string price : number example : name : Snoopy kind : Dog price : 1000 D\u00e9finir des param\u00e8tres pour les m\u00e9thodes \u00b6 Nous nous proposons d\u2019ajouter une autre m\u00e9thode de type get , qui d\u00e9finit plusieurs param\u00e8tres. Pour cela, Sous (et au m\u00eame niveau que) type de /pets , taper: get: Ajouter le code suivant: get : queryParameters : priceLessThan : number priceMoreThan : number petKind : enum : - bird - dog Il est possible d\u2019extraire certains des param\u00e8tres comme Trait , c\u2019est \u00e0 dire un crit\u00e8re de filtrage. Pour cela, ajouter le code suivant au dessus de resourceTypes : traits : FiltrableByPrice : queryParameters : priceLessThan : number priceMoreThan : number Cr\u00e9ation du service \u00b6 Dans Anypoint Studio, cr\u00e9er un nouveau Mule Project: Appeler le projet MyRESTApp Choisir Mule Server comme Runtime Environment . Cliquer sur Finish . Nous allons commencer par cr\u00e9er une simple application qui affiche un message. \u00c0 partir de la palette, glisser-d\u00e9placer les \u00e9l\u00e9ments graphiques suivants dans le canevas: HTTP Listener : permet de se connecter aux ressources web via HTTP ou HTTPS. Set Payload : modifie le message affich\u00e9 (payload) en \"Hello World!\". Votre flux aura l\u2019allure suivante: Configurer votre composant Listener : Ajouter une nouvelle Connector Configuration Garder les options par d\u00e9faut. Votre h\u00f4te se lancera \u00e0 l\u2019URL 0.0.0.0:8081 D\u00e9finir le path comme /hello (ceci repr\u00e9sente le chemin relatif \u00e0 partir du chemin de base d\u00e9fini dans la configuration du listener). Configurer le composant Set Payload: Remplacer la valeur de l\u2019\u00e9l\u00e9ment Value par Hello World!! Lancer votre application : Run -> Run As -> Mule Application. La console devrait afficher un message comme suit: Dans un navigateur, taper l'adresse: 0.0.0.0:8081/hello . Un fichier contenant le message Hello World! devra \u00eatre disponible. Gestion des APIs avec APIKit \u00b6 APIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs. Nous allons pour cela exposer l'API REST que nous avons cr\u00e9\u00e9 avec Talend dans la deuxi\u00e8me partie du TP1 . Cr\u00e9ation d'un fichier RAML pour le service \u00b6 Pour repr\u00e9senter le service \"Get Users\", cr\u00e9er le fichier usersapi.raml suivant dans API Designer: #%RAML 1.0 title : My-API version : v1 baseUri : http://localhost:8081 /users : get : description : List of all the users responses : 200 : body : application/xml : example : !include users-example.xml Rajouter \u00e9galement (dans le m\u00eame r\u00e9pertoire) un fichier users-example.xml , o\u00f9 vous allez trouver un exemple de users, tel qu'ils sont repr\u00e9sent\u00e9s par votre service sur http://localhost:8088/users . Cela devrait ressembler \u00e0 ce qui suit: <users> <user id= \"11\" > <firstname> Flen </firstname> <lastname> Fouleni </lastname> </user> <user id= \"22\" > <firstname> Flena </firstname> <lastname> Flenia </lastname> </user> </users> Nouveau Projet de API Management \u00b6 Cr\u00e9er un nouveau Mule Project qu\u2019on appellera API_Project : Choisir comme environnement d\u2019ex\u00e9cution Mule Server. Cliquer sur l'onglet Import RAML from local file et choisir le fichier usersapi.raml que vous venez de cr\u00e9er. Un nouveau projet sera cr\u00e9\u00e9 avec les fichiers usersapi.raml et users-example.xml ajout\u00e9s sous le r\u00e9pertoire src/main/resources/api , ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment: Flux Description Figure usersapi-main Flux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception action:/ressource:api-config Un Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products Configuration du flux principal \u00b6 Dans les propri\u00e9t\u00e9s du composant Listener, d\u00e9finir le Path comme: /* . Dans le Connector Configuration , cliquer sur l'ic\u00f4ne , puis cliquer sur OK pour valider le host (0.0.0.0) et le port (8081) Remarque Vous pouvez changer ici le port d\u00e9fini par d\u00e9faut, pour \u00e9viter les conflits potentiels avec d'autres services. Lancer le projet comme Mule Application . Pour commencer, afficher la documentation de l'API dans une APIKit Console . Pour cela: Aller \u00e0 Window -> Show View -> Other... Choisir APIKit View -> APIKit Consoles Une vue va s'afficher comme suit: Cliquer sur Open Console . Une fen\u00eatre va s'afficher sur votre navigateur, comme suit: Pour consulter votre API, cliquer par exemple sur le bouton GET de la ressource /users . La console affichera alors la r\u00e9ponse, qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part. Pour visualiser le r\u00e9sultat sur le navigateur, taper le chemin de la requ\u00eate comme suit: http://localhost:8081/users Vous obtiendrez le r\u00e9sultat suivant: Mapping de l'API avec le service \u00b6 Pour relier votre API cr\u00e9\u00e9e avec le service du TP1 (n'oubliez pas de le lancer ), qui est d\u00e9ploy\u00e9 \u00e0 l'adresse suivante: http://localhost:8088/users Supprimer le Transform Message du flow : get:/users:usersapi-config Ajouter un connecteur HTTP Listener dans la partie Source Le configurer comme suit: Path: /all-users Cliquer sur puis sur OK pour valider le h\u00f4te et port. Ajouter un connecteur HTTP Request dans la partie Process Le configurer comme suit: Devant Configuration , cliquer sur pour ajouter une nouvelle configuration. Cela repr\u00e9sente les informations du service auquel on va acc\u00e9der. D\u00e9finir le Host par localhost , le port par 8088 , et le base path par / Cliquer sur OK pour valider Dans la partie Request , d\u00e9finir : Method: Get Path: /users?from=1&to=4 URL ( Laisser vide ) Sauvegarder, et lancer le service. Tester le service sur le navigateur avec l'URL: http://localhost:8081/all-users . Vous obtiendrez la liste compl\u00e8te des utilisateurs de votre base, tels que retourn\u00e9s par le service initial, comme suit (le contenu exact d\u00e9pend bien entendu de votre base de donn\u00e9es): Transformation du r\u00e9sultat du service \u00b6 Nous allons maintenant retourner un r\u00e9sultat diff\u00e9rent du service initial. Par exemple, nous allons afficher uniquement les pr\u00e9noms des users, mais cette fois-ci dans un document JSON. Pour cela, utiliser un objet Transform Message . Dans le code XML de votre usersapi , copier le flow get:/users pour cr\u00e9er un autre flow identique (modifier le nom du flow pour qu'il devienne, par exemple, \"getnames:\\users:usersapi-config\" ) Modifier le Path du connecteur HTTP source, pour /all-users/names Rajouter un objet Transform Message juste apr\u00e8s le connecteur HTTP de droite (celui de la partie Process). Le flow devra ressembler \u00e0 ce qui suit: Configurer l'objet Transform Message : L'interface suivante repr\u00e9sente les mappings \u00e0 faire entre les entr\u00e9es du service et sa sortie. Cliquer sur Define Metadata du payload en entr\u00e9e (\u00e0 gauche) Cliquer sur Add Entrer le nom du type en entr\u00e9e, par exemple users Indiquer comme type XML Indiquer dans la liste d\u00e9roulante suivante que le fichier donn\u00e9 est un Example , puis choisir le fichier users-example.xml que vous aviez cr\u00e9\u00e9. Cliquer sur Select. Le sch\u00e9ma du fichier donn\u00e9 est charg\u00e9 dans la partie Input de Transform Message . Pour repr\u00e9senter le format de sortie d\u00e9sir\u00e9, cr\u00e9er un fichier appel\u00e9 names.json \u00e0 l'endroit de votre pr\u00e9f\u00e9rence sur votre ordinateur. Saisir le contenu suivant dans names.json : { \"users\" : [ { \"name\" : \"Name 1\" }, { \"name\" : \"Name 2\" } ] } Cliquer sur Define Metadata de sortie (\u00e0 droite). Ajouter un nouveau type que vous appellerez names D\u00e9finir comme type JSON et charger le fichier names.json que vous venez de cr\u00e9er. Valider. Maintenant que les deux sch\u00e9mas (entr\u00e9e et sortie) sont d\u00e9finis, cr\u00e9er les associations de votre choix. Dans notre cas, nous allons associer le champ firstname en entr\u00e9e au champ name en sortie, comme suit: Sauvegarder, et lancer le service. Pour tester le service, lancer dans un navigateur: http://localhost:8081/all-users/names . Vous obtiendrez le r\u00e9sultat suivant: Homework \u00b6 Projet E2 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 2 du projet, qui consiste \u00e0: Terminer les diagrammes de votre entreprise commenc\u00e9s la semaine d'avant. Concevoir et commencer l'impl\u00e9mentation des services n\u00e9cessaires pour votre PoC. R\u00e9fl\u00e9chir \u00e0 l'usage des ESB, leur r\u00f4le et les strat\u00e9gies qui y seront impl\u00e9ment\u00e9es.","title":"Tp4 old"},{"location":"tp4-old/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp4-old/#objectifs-du-tp","text":"G\u00e9n\u00e9ration d\u2019API avec Anypoint API Designer et le langage RAML Gestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft","title":"Objectifs du TP"},{"location":"tp4-old/#outils-et-versions","text":"Anypoint Studio 7 and Mule ESB 4 MySQL Version latest !!!!!!!! Dans ce TP, nous aurons besoin du service cr\u00e9\u00e9 dans le TP1 , ou bien de n'importe quel service REST de votre choix","title":"Outils et Versions"},{"location":"tp4-old/#api-management-avec-anypoint-studio","text":"","title":"API Management avec Anypoint Studio"},{"location":"tp4-old/#generation-dapi-avec-raml","text":"","title":"G\u00e9n\u00e9ration d'API avec RAML"},{"location":"tp4-old/#raml","text":"RAML (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful. RAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles technologies, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage.","title":"RAML"},{"location":"tp4-old/#generation-de-lapi-raml-avec-anypoint-api-designer","text":"Pour \u00e9crire un document RAML de mani\u00e8re simple et intuitive, ouvrir Anypoint Studio, et cr\u00e9er un nouveau projet de type \"API Specification Project\" , intitul\u00e9 Pet Shop de type RAML 1.0 . L'interface suivante devra s'afficher:","title":"G\u00e9n\u00e9ration de l'API RAML avec AnyPoint API Designer"},{"location":"tp4-old/#creation-dun-document-raml","text":"Dans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations d\u00e9crites dans le cours.","title":"Cr\u00e9ation d\u2019un document RAML"},{"location":"tp4-old/#creation-dune-api-raml","text":"Remplir le fichier pet-shop.raml cr\u00e9\u00e9 pour qu'il ressemble \u00e0 ce qui suit: #RAML 1.0 title : Pet Shop version : v1 baseUri : /pets /pets : get : responses : 200 : body : application/json : properties : name : string kind : string price : number post : body : application/json : properties : name : string kind : string price : number /{id} : delete : responses : 204 : put : body : application/json : properties : name : string kind : string price : number Dans cette description, nous d\u00e9finissons le comportement principal de l'API, \u00e0 l'appel des quatre m\u00e9thodes les plus fr\u00e9quentes: un GET ou un POST sur la ressource principale, et un DELETE ou un PUT sur un objet particulier repr\u00e9sent\u00e9 par son id .","title":"Cr\u00e9ation d\u2019une API RAML"},{"location":"tp4-old/#definir-des-types","text":"Pour \u00e9viter les redondances constat\u00e9es dans notre d\u00e9finition, nous cr\u00e9ons le type Pet . Pour cela: Dans une nouvelle ligne au dessus de /pets , taper les lignes suivantes: types : Pet : properties : name : string kind : string price : number D\u00e9finir Pet comme type pour le corps de la m\u00e9thode post , en \u00e9crivant: type: Pet au dessous de application/json de la m\u00e9thode post Ajouter de m\u00eame Pet comme type pour la m\u00e9thode put, et Pet[] pour la m\u00e9thode get.","title":"D\u00e9finir des types"},{"location":"tp4-old/#extraction-dun-type-de-ressources","text":"Pour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante: Ajouter le code suivant au dessus du title : resourceTypes : Collection : get : responses : 200 : body : application/json : type : Pet[] post : body : application/json : type : Pet Member : delete : responses : 204 : put : body : application/json : type : Pet Supprimer le contenu de /pets et de /{id} pour le remplacer par les nouveaux resourceTypes d\u00e9finis en utilisant: type: Collection et type: Member .","title":"Extraction d\u2019un type de ressources"},{"location":"tp4-old/#ajout-de-parametres-au-type-de-ressource","text":"Pour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela: Remplacer le terme Pet dans Collection et Member par <<item>> . Remplacer les ressources Collection et Member respectivement par { Collection: {item : Pet} } et { Member: {item : Pet} }","title":"Ajout de param\u00e8tres au type de ressource"},{"location":"tp4-old/#ajout-dun-exemple","text":"Pour ajouter un exemple d\u2019animal, modifier le type Pet pour qu\u2019il soit comme suit: types : Pet : properties : name : string kind : string price : number example : name : Snoopy kind : Dog price : 1000","title":"Ajout d\u2019un exemple"},{"location":"tp4-old/#definir-des-parametres-pour-les-methodes","text":"Nous nous proposons d\u2019ajouter une autre m\u00e9thode de type get , qui d\u00e9finit plusieurs param\u00e8tres. Pour cela, Sous (et au m\u00eame niveau que) type de /pets , taper: get: Ajouter le code suivant: get : queryParameters : priceLessThan : number priceMoreThan : number petKind : enum : - bird - dog Il est possible d\u2019extraire certains des param\u00e8tres comme Trait , c\u2019est \u00e0 dire un crit\u00e8re de filtrage. Pour cela, ajouter le code suivant au dessus de resourceTypes : traits : FiltrableByPrice : queryParameters : priceLessThan : number priceMoreThan : number","title":"D\u00e9finir des param\u00e8tres pour les m\u00e9thodes"},{"location":"tp4-old/#creation-du-service","text":"Dans Anypoint Studio, cr\u00e9er un nouveau Mule Project: Appeler le projet MyRESTApp Choisir Mule Server comme Runtime Environment . Cliquer sur Finish . Nous allons commencer par cr\u00e9er une simple application qui affiche un message. \u00c0 partir de la palette, glisser-d\u00e9placer les \u00e9l\u00e9ments graphiques suivants dans le canevas: HTTP Listener : permet de se connecter aux ressources web via HTTP ou HTTPS. Set Payload : modifie le message affich\u00e9 (payload) en \"Hello World!\". Votre flux aura l\u2019allure suivante: Configurer votre composant Listener : Ajouter une nouvelle Connector Configuration Garder les options par d\u00e9faut. Votre h\u00f4te se lancera \u00e0 l\u2019URL 0.0.0.0:8081 D\u00e9finir le path comme /hello (ceci repr\u00e9sente le chemin relatif \u00e0 partir du chemin de base d\u00e9fini dans la configuration du listener). Configurer le composant Set Payload: Remplacer la valeur de l\u2019\u00e9l\u00e9ment Value par Hello World!! Lancer votre application : Run -> Run As -> Mule Application. La console devrait afficher un message comme suit: Dans un navigateur, taper l'adresse: 0.0.0.0:8081/hello . Un fichier contenant le message Hello World! devra \u00eatre disponible.","title":"Cr\u00e9ation du service"},{"location":"tp4-old/#gestion-des-apis-avec-apikit","text":"APIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs. Nous allons pour cela exposer l'API REST que nous avons cr\u00e9\u00e9 avec Talend dans la deuxi\u00e8me partie du TP1 .","title":"Gestion des APIs avec APIKit"},{"location":"tp4-old/#creation-dun-fichier-raml-pour-le-service","text":"Pour repr\u00e9senter le service \"Get Users\", cr\u00e9er le fichier usersapi.raml suivant dans API Designer: #%RAML 1.0 title : My-API version : v1 baseUri : http://localhost:8081 /users : get : description : List of all the users responses : 200 : body : application/xml : example : !include users-example.xml Rajouter \u00e9galement (dans le m\u00eame r\u00e9pertoire) un fichier users-example.xml , o\u00f9 vous allez trouver un exemple de users, tel qu'ils sont repr\u00e9sent\u00e9s par votre service sur http://localhost:8088/users . Cela devrait ressembler \u00e0 ce qui suit: <users> <user id= \"11\" > <firstname> Flen </firstname> <lastname> Fouleni </lastname> </user> <user id= \"22\" > <firstname> Flena </firstname> <lastname> Flenia </lastname> </user> </users>","title":"Cr\u00e9ation d'un fichier RAML pour le service"},{"location":"tp4-old/#nouveau-projet-de-api-management","text":"Cr\u00e9er un nouveau Mule Project qu\u2019on appellera API_Project : Choisir comme environnement d\u2019ex\u00e9cution Mule Server. Cliquer sur l'onglet Import RAML from local file et choisir le fichier usersapi.raml que vous venez de cr\u00e9er. Un nouveau projet sera cr\u00e9\u00e9 avec les fichiers usersapi.raml et users-example.xml ajout\u00e9s sous le r\u00e9pertoire src/main/resources/api , ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment: Flux Description Figure usersapi-main Flux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception action:/ressource:api-config Un Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products","title":"Nouveau Projet de API Management"},{"location":"tp4-old/#configuration-du-flux-principal","text":"Dans les propri\u00e9t\u00e9s du composant Listener, d\u00e9finir le Path comme: /* . Dans le Connector Configuration , cliquer sur l'ic\u00f4ne , puis cliquer sur OK pour valider le host (0.0.0.0) et le port (8081) Remarque Vous pouvez changer ici le port d\u00e9fini par d\u00e9faut, pour \u00e9viter les conflits potentiels avec d'autres services. Lancer le projet comme Mule Application . Pour commencer, afficher la documentation de l'API dans une APIKit Console . Pour cela: Aller \u00e0 Window -> Show View -> Other... Choisir APIKit View -> APIKit Consoles Une vue va s'afficher comme suit: Cliquer sur Open Console . Une fen\u00eatre va s'afficher sur votre navigateur, comme suit: Pour consulter votre API, cliquer par exemple sur le bouton GET de la ressource /users . La console affichera alors la r\u00e9ponse, qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part. Pour visualiser le r\u00e9sultat sur le navigateur, taper le chemin de la requ\u00eate comme suit: http://localhost:8081/users Vous obtiendrez le r\u00e9sultat suivant:","title":"Configuration du flux principal"},{"location":"tp4-old/#mapping-de-lapi-avec-le-service","text":"Pour relier votre API cr\u00e9\u00e9e avec le service du TP1 (n'oubliez pas de le lancer ), qui est d\u00e9ploy\u00e9 \u00e0 l'adresse suivante: http://localhost:8088/users Supprimer le Transform Message du flow : get:/users:usersapi-config Ajouter un connecteur HTTP Listener dans la partie Source Le configurer comme suit: Path: /all-users Cliquer sur puis sur OK pour valider le h\u00f4te et port. Ajouter un connecteur HTTP Request dans la partie Process Le configurer comme suit: Devant Configuration , cliquer sur pour ajouter une nouvelle configuration. Cela repr\u00e9sente les informations du service auquel on va acc\u00e9der. D\u00e9finir le Host par localhost , le port par 8088 , et le base path par / Cliquer sur OK pour valider Dans la partie Request , d\u00e9finir : Method: Get Path: /users?from=1&to=4 URL ( Laisser vide ) Sauvegarder, et lancer le service. Tester le service sur le navigateur avec l'URL: http://localhost:8081/all-users . Vous obtiendrez la liste compl\u00e8te des utilisateurs de votre base, tels que retourn\u00e9s par le service initial, comme suit (le contenu exact d\u00e9pend bien entendu de votre base de donn\u00e9es):","title":"Mapping de l'API avec le service"},{"location":"tp4-old/#transformation-du-resultat-du-service","text":"Nous allons maintenant retourner un r\u00e9sultat diff\u00e9rent du service initial. Par exemple, nous allons afficher uniquement les pr\u00e9noms des users, mais cette fois-ci dans un document JSON. Pour cela, utiliser un objet Transform Message . Dans le code XML de votre usersapi , copier le flow get:/users pour cr\u00e9er un autre flow identique (modifier le nom du flow pour qu'il devienne, par exemple, \"getnames:\\users:usersapi-config\" ) Modifier le Path du connecteur HTTP source, pour /all-users/names Rajouter un objet Transform Message juste apr\u00e8s le connecteur HTTP de droite (celui de la partie Process). Le flow devra ressembler \u00e0 ce qui suit: Configurer l'objet Transform Message : L'interface suivante repr\u00e9sente les mappings \u00e0 faire entre les entr\u00e9es du service et sa sortie. Cliquer sur Define Metadata du payload en entr\u00e9e (\u00e0 gauche) Cliquer sur Add Entrer le nom du type en entr\u00e9e, par exemple users Indiquer comme type XML Indiquer dans la liste d\u00e9roulante suivante que le fichier donn\u00e9 est un Example , puis choisir le fichier users-example.xml que vous aviez cr\u00e9\u00e9. Cliquer sur Select. Le sch\u00e9ma du fichier donn\u00e9 est charg\u00e9 dans la partie Input de Transform Message . Pour repr\u00e9senter le format de sortie d\u00e9sir\u00e9, cr\u00e9er un fichier appel\u00e9 names.json \u00e0 l'endroit de votre pr\u00e9f\u00e9rence sur votre ordinateur. Saisir le contenu suivant dans names.json : { \"users\" : [ { \"name\" : \"Name 1\" }, { \"name\" : \"Name 2\" } ] } Cliquer sur Define Metadata de sortie (\u00e0 droite). Ajouter un nouveau type que vous appellerez names D\u00e9finir comme type JSON et charger le fichier names.json que vous venez de cr\u00e9er. Valider. Maintenant que les deux sch\u00e9mas (entr\u00e9e et sortie) sont d\u00e9finis, cr\u00e9er les associations de votre choix. Dans notre cas, nous allons associer le champ firstname en entr\u00e9e au champ name en sortie, comme suit: Sauvegarder, et lancer le service. Pour tester le service, lancer dans un navigateur: http://localhost:8081/all-users/names . Vous obtiendrez le r\u00e9sultat suivant:","title":"Transformation du r\u00e9sultat du service"},{"location":"tp4-old/#homework","text":"Projet E2 Pour la s\u00e9ance de TP prochaine, vous devez r\u00e9aliser l'\u00e9tape 2 du projet, qui consiste \u00e0: Terminer les diagrammes de votre entreprise commenc\u00e9s la semaine d'avant. Concevoir et commencer l'impl\u00e9mentation des services n\u00e9cessaires pour votre PoC. R\u00e9fl\u00e9chir \u00e0 l'usage des ESB, leur r\u00f4le et les strat\u00e9gies qui y seront impl\u00e9ment\u00e9es.","title":"Homework"},{"location":"tp4/","text":"T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Le TP vise \u00e0 int\u00e9grer MuleSoft et Camunda pour automatiser un processus m\u00e9tier. L'exemple choisi est un processus de demande de cong\u00e9 qui utilisera \u00e0 la fois des services REST et SOAP. Outils et Versions \u00b6 Anypoint Studio 7 and Mule ESB 4 Camunda - Version latest VsCode - Version latest (ou tout autre IDE de votre choix) Java - Version 17 ou plus. SOAP UI (Open Source) Version 5.7.0 MySQL Version latest Description du Processus \u00b6 Nous allons d\u00e9velopper un processus m\u00e9tier permetant de simuler une demande de cong\u00e9. Le processus est d\u00e9crit comme suit: Un employ\u00e9 initie une demande de cong\u00e9 via une interface utilisateur. L'employ\u00e9 remplit un formulaire avec les d\u00e9tails de la demande (date de d\u00e9but, date de fin, type de cong\u00e9, etc.). La demande est envoy\u00e9e pour approbation. Un service permet de v\u00e9rifier les droits de cong\u00e9 de l'employ\u00e9 (jours disponibles, types de cong\u00e9s autoris\u00e9s, etc.). Le responsable de l'employ\u00e9 va approuver ou refuser la demande. Si la demande est approuv\u00e9e: Un service est appel\u00e9 pour enregistrer la d\u00e9cision dans le syst\u00e8me de gestion des cong\u00e9s (une base de donn\u00e9es). Un autre service met \u00e0 jour les informations de cong\u00e9 de l'employ\u00e9 (d\u00e9compter les jours de cong\u00e9, etc.). L'employ\u00e9 est notifi\u00e9 de la d\u00e9cision (approuv\u00e9e ou refus\u00e9e). Le processus se termine une fois la notification envoy\u00e9e. Cr\u00e9ation et D\u00e9ploiement des Services sur MuleSoft \u00b6 Il vous est demand\u00e9 de cr\u00e9er les services automatis\u00e9s sur MuleSoft: Cr\u00e9ation du service de gestion des employ\u00e9s : Cr\u00e9er un service REST qui g\u00e8re les informations des employ\u00e9s, impl\u00e9mentant les m\u00e9thodes suivantes: GET pour r\u00e9cup\u00e9rer les informations des employ\u00e9s POST pour mettre \u00e0 jour les informations, telles que les jours de cong\u00e9. Cr\u00e9ation du service d'approbation de cong\u00e9 : Ceci est un service SOAP, contenant : Une m\u00e9thode pour soumettre une demande de cong\u00e9 Une autre m\u00e9thode pour v\u00e9rifier le statut de la demande. Il faut ensuite tester les deux services avec votre outil pr\u00e9f\u00e9r\u00e9 (SOAPUI et/ou Postman). Mod\u00e9lisation du processus avec Camunda Modeler \u00b6 Il vous est ensuite demand\u00e9 de mod\u00e9liser le service m\u00e9tier d\u00e9crit avec Camunda Modeler, en cr\u00e9ant les formulaires associ\u00e9s et en configurant les diff\u00e9rentes t\u00e2ches pour qu'elles appellent les services d\u00e9ploy\u00e9s sur MuleSoft. Projet \u00b6 \u00c9tape 4 Finaliser votre projet en int\u00e9grant les diff\u00e9rents services et processus m\u00e9tier avec votre ESB. Le POC devrait \u00eatre ex\u00e9cutable et complet pour la pr\u00e9sentation finale du projet.","title":"TP4 - Int\u00e9gration BPM et ESB"},{"location":"tp4/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp4/#objectifs-du-tp","text":"Le TP vise \u00e0 int\u00e9grer MuleSoft et Camunda pour automatiser un processus m\u00e9tier. L'exemple choisi est un processus de demande de cong\u00e9 qui utilisera \u00e0 la fois des services REST et SOAP.","title":"Objectifs du TP"},{"location":"tp4/#outils-et-versions","text":"Anypoint Studio 7 and Mule ESB 4 Camunda - Version latest VsCode - Version latest (ou tout autre IDE de votre choix) Java - Version 17 ou plus. SOAP UI (Open Source) Version 5.7.0 MySQL Version latest","title":"Outils et Versions"},{"location":"tp4/#description-du-processus","text":"Nous allons d\u00e9velopper un processus m\u00e9tier permetant de simuler une demande de cong\u00e9. Le processus est d\u00e9crit comme suit: Un employ\u00e9 initie une demande de cong\u00e9 via une interface utilisateur. L'employ\u00e9 remplit un formulaire avec les d\u00e9tails de la demande (date de d\u00e9but, date de fin, type de cong\u00e9, etc.). La demande est envoy\u00e9e pour approbation. Un service permet de v\u00e9rifier les droits de cong\u00e9 de l'employ\u00e9 (jours disponibles, types de cong\u00e9s autoris\u00e9s, etc.). Le responsable de l'employ\u00e9 va approuver ou refuser la demande. Si la demande est approuv\u00e9e: Un service est appel\u00e9 pour enregistrer la d\u00e9cision dans le syst\u00e8me de gestion des cong\u00e9s (une base de donn\u00e9es). Un autre service met \u00e0 jour les informations de cong\u00e9 de l'employ\u00e9 (d\u00e9compter les jours de cong\u00e9, etc.). L'employ\u00e9 est notifi\u00e9 de la d\u00e9cision (approuv\u00e9e ou refus\u00e9e). Le processus se termine une fois la notification envoy\u00e9e.","title":"Description du Processus"},{"location":"tp4/#creation-et-deploiement-des-services-sur-mulesoft","text":"Il vous est demand\u00e9 de cr\u00e9er les services automatis\u00e9s sur MuleSoft: Cr\u00e9ation du service de gestion des employ\u00e9s : Cr\u00e9er un service REST qui g\u00e8re les informations des employ\u00e9s, impl\u00e9mentant les m\u00e9thodes suivantes: GET pour r\u00e9cup\u00e9rer les informations des employ\u00e9s POST pour mettre \u00e0 jour les informations, telles que les jours de cong\u00e9. Cr\u00e9ation du service d'approbation de cong\u00e9 : Ceci est un service SOAP, contenant : Une m\u00e9thode pour soumettre une demande de cong\u00e9 Une autre m\u00e9thode pour v\u00e9rifier le statut de la demande. Il faut ensuite tester les deux services avec votre outil pr\u00e9f\u00e9r\u00e9 (SOAPUI et/ou Postman).","title":"Cr\u00e9ation et D\u00e9ploiement des Services sur MuleSoft"},{"location":"tp4/#modelisation-du-processus-avec-camunda-modeler","text":"Il vous est ensuite demand\u00e9 de mod\u00e9liser le service m\u00e9tier d\u00e9crit avec Camunda Modeler, en cr\u00e9ant les formulaires associ\u00e9s et en configurant les diff\u00e9rentes t\u00e2ches pour qu'elles appellent les services d\u00e9ploy\u00e9s sur MuleSoft.","title":"Mod\u00e9lisation du processus avec Camunda Modeler"},{"location":"tp4/#projet","text":"\u00c9tape 4 Finaliser votre projet en int\u00e9grant les diff\u00e9rents services et processus m\u00e9tier avec votre ESB. Le POC devrait \u00eatre ex\u00e9cutable et complet pour la pr\u00e9sentation finale du projet.","title":"Projet"},{"location":"slides/intro/","text":"Additional Documentation Some references...","title":"Intro"},{"location":"slides/template/","text":"Additional Documentation Some references...","title":"Template"}]}